(() => {
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };

  // <stdin>
  var require_stdin = __commonJS({
    "<stdin>"(exports, module) {
      !function(e, t) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).bootstrap = t();
      }(exports, function() {
        "use strict";
        const w = /* @__PURE__ */ new Map(), pt = { set(e2, t2, n2) {
          w.has(e2) || w.set(e2, /* @__PURE__ */ new Map());
          const s2 = w.get(e2);
          s2.has(t2) || 0 === s2.size ? s2.set(t2, n2) : console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s2.keys())[0]}.`);
        }, get: (e2, t2) => w.has(e2) && w.get(e2).get(t2) || null, remove(e2, t2) {
          if (!w.has(e2)) return;
          const n2 = w.get(e2);
          n2.delete(t2), 0 === n2.size && w.delete(e2);
        } }, ft = "transitionend", At = (e2) => (e2 && window.CSS && window.CSS.escape && (e2 = e2.replace(/#([^\s"#']+)/g, (e3, t2) => `#${CSS.escape(t2)}`)), e2), zt = (e2) => {
          e2.dispatchEvent(new Event(ft));
        }, j = (e2) => !!e2 && "object" == typeof e2 && (void 0 !== e2.jquery && (e2 = e2[0]), void 0 !== e2.nodeType), x = (e2) => j(e2) ? e2.jquery ? e2[0] : e2 : "string" == typeof e2 && e2.length > 0 ? document.querySelector(At(e2)) : null, V = (e2) => {
          if (!j(e2) || 0 === e2.getClientRects().length) return false;
          const n2 = "visible" === getComputedStyle(e2).getPropertyValue("visibility"), t2 = e2.closest("details:not([open])");
          if (!t2) return n2;
          if (t2 !== e2) {
            const n3 = e2.closest("summary");
            if (n3 && n3.parentNode !== t2) return false;
            if (null === n3) return false;
          }
          return n2;
        }, O = (e2) => !e2 || e2.nodeType !== Node.ELEMENT_NODE || !!e2.classList.contains("disabled") || (void 0 !== e2.disabled ? e2.disabled : e2.hasAttribute("disabled") && "false" !== e2.getAttribute("disabled")), Dt = (e2) => {
          if (!document.documentElement.attachShadow) return null;
          if ("function" == typeof e2.getRootNode) {
            const t2 = e2.getRootNode();
            return t2 instanceof ShadowRoot ? t2 : null;
          }
          return e2 instanceof ShadowRoot ? e2 : e2.parentNode ? Dt(e2.parentNode) : null;
        }, ce = () => {
        }, oe = (e2) => {
          e2.offsetHeight;
        }, Bt = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null, mt = [], d = () => "rtl" === document.documentElement.dir, u = (e2) => {
          var t2 = () => {
            const t3 = Bt();
            if (t3) {
              const n2 = e2.NAME, s2 = t3.fn[n2];
              t3.fn[n2] = e2.jQueryInterface, t3.fn[n2].Constructor = e2, t3.fn[n2].noConflict = () => (t3.fn[n2] = s2, e2.jQueryInterface);
            }
          };
          "loading" === document.readyState ? (mt.length || document.addEventListener("DOMContentLoaded", () => {
            for (const e3 of mt) e3();
          }), mt.push(t2)) : t2();
        }, o = (e2, t2 = [], n2 = e2) => "function" == typeof e2 ? e2(...t2) : n2, Vt = (e2, t2, n2 = true) => {
          if (!n2) return void o(e2);
          const a2 = ((e3) => {
            if (!e3) return 0;
            let { transitionDuration: t3, transitionDelay: n3 } = window.getComputedStyle(e3);
            const s3 = Number.parseFloat(t3), o2 = Number.parseFloat(n3);
            return s3 || o2 ? (t3 = t3.split(",")[0], n3 = n3.split(",")[0], 1e3 * (Number.parseFloat(t3) + Number.parseFloat(n3))) : 0;
          })(t2) + 5;
          let s2 = false;
          const i2 = ({ target: n3 }) => {
            n3 === t2 && (s2 = true, t2.removeEventListener(ft, i2), o(e2));
          };
          t2.addEventListener(ft, i2), setTimeout(() => {
            s2 || zt(t2);
          }, a2);
        }, ht = (e2, t2, n2, s2) => {
          const i2 = e2.length;
          let o2 = e2.indexOf(t2);
          return -1 === o2 ? !n2 && s2 ? e2[i2 - 1] : e2[0] : (o2 += n2 ? 1 : -1, s2 && (o2 = (o2 + i2) % i2), e2[Math.max(0, Math.min(o2, i2 - 1))]);
        }, Ko = /[^.]*(?=\..*)\.|.*/, Wo = /\..*/, Vo = /::\d+$/, rt = {};
        let Gt = 1;
        const Zt = { mouseenter: "mouseover", mouseleave: "mouseout" }, Eo = /* @__PURE__ */ new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
        function hn(e2, t2) {
          return t2 && `${t2}::${Gt++}` || e2.uidEvent || Gt++;
        }
        function fn(e2) {
          const t2 = hn(e2);
          return e2.uidEvent = t2, rt[t2] = rt[t2] || {}, rt[t2];
        }
        function gn(e2, t2, n2 = null) {
          return Object.values(e2).find((e3) => e3.callable === t2 && e3.delegationSelector === n2);
        }
        function bn(e2, t2, n2) {
          const o2 = "string" == typeof t2, i2 = o2 ? n2 : t2 || n2;
          let s2 = wn(e2);
          return Eo.has(s2) || (s2 = e2), [o2, i2, s2];
        }
        function jn(t2, n2, s2, o2, i2) {
          if ("string" != typeof n2 || !t2) return;
          let [c2, a2, l2] = bn(n2, s2, o2);
          if (n2 in Zt) {
            const e2 = (e3) => function(t3) {
              if (!t3.relatedTarget || t3.relatedTarget !== t3.delegateTarget && !t3.delegateTarget.contains(t3.relatedTarget)) return e3.call(this, t3);
            };
            a2 = e2(a2);
          }
          const u2 = fn(t2), h2 = u2[l2] || (u2[l2] = {}), d2 = gn(h2, a2, c2 ? s2 : null);
          if (d2) return void (d2.oneOff = d2.oneOff && i2);
          const m2 = hn(a2, n2.replace(Ko, "")), r2 = c2 ? /* @__PURE__ */ function(t3, n3, s3) {
            return function o3(i3) {
              const a3 = t3.querySelectorAll(n3);
              for (let { target: r3 } = i3; r3 && r3 !== this; r3 = r3.parentNode) for (const c3 of a3) if (c3 === r3) return Ge(i3, { delegateTarget: r3 }), o3.oneOff && e.off(t3, i3.type, n3, s3), s3.apply(r3, [i3]);
            };
          }(t2, s2, a2) : /* @__PURE__ */ function(t3, n3) {
            return function s3(o3) {
              return Ge(o3, { delegateTarget: t3 }), s3.oneOff && e.off(t3, o3.type, n3), n3.apply(t3, [o3]);
            };
          }(t2, a2);
          r2.delegationSelector = c2 ? s2 : null, r2.callable = a2, r2.oneOff = i2, r2.uidEvent = m2, h2[m2] = r2, t2.addEventListener(l2, r2, c2);
        }
        function Ze(e2, t2, n2, s2, o2) {
          const i2 = gn(t2[n2], s2, o2);
          i2 && (e2.removeEventListener(n2, i2, Boolean(o2)), delete t2[n2][i2.uidEvent]);
        }
        function uo(e2, t2, n2, s2) {
          const o2 = t2[n2] || {};
          for (const [a2, i2] of Object.entries(o2)) a2.includes(s2) && Ze(e2, t2, n2, i2.callable, i2.delegationSelector);
        }
        function wn(e2) {
          return e2 = e2.replace(Wo, ""), Zt[e2] || e2;
        }
        const e = { on(e2, t2, n2, s2) {
          jn(e2, t2, n2, s2, false);
        }, one(e2, t2, n2, s2) {
          jn(e2, t2, n2, s2, true);
        }, off(e2, t2, n2, s2) {
          if ("string" != typeof t2 || !e2) return;
          const [c2, a2, i2] = bn(t2, n2, s2), l2 = i2 !== t2, o2 = fn(e2), r2 = o2[i2] || {}, d2 = t2.startsWith(".");
          if (void 0 === a2) {
            if (d2) for (const n3 of Object.keys(o2)) uo(e2, o2, n3, t2.slice(1));
            for (const [s3, n3] of Object.entries(r2)) {
              const a3 = s3.replace(Vo, "");
              l2 && !t2.includes(a3) || Ze(e2, o2, i2, n3.callable, n3.delegationSelector);
            }
          } else {
            if (!Object.keys(r2).length) return;
            Ze(e2, o2, i2, a2, c2 ? n2 : null);
          }
        }, trigger(e2, t2, n2) {
          if ("string" != typeof t2 || !e2) return null;
          const i2 = Bt();
          let s2 = null, a2 = true, r2 = true, c2 = false;
          t2 !== wn(t2) && i2 && (s2 = i2.Event(t2, n2), i2(e2).trigger(s2), a2 = !s2.isPropagationStopped(), r2 = !s2.isImmediatePropagationStopped(), c2 = s2.isDefaultPrevented());
          const o2 = Ge(new Event(t2, { bubbles: a2, cancelable: true }), n2);
          return c2 && o2.preventDefault(), r2 && e2.dispatchEvent(o2), o2.defaultPrevented && s2 && s2.preventDefault(), o2;
        } };
        function Ge(e2, t2 = {}) {
          for (const [n2, s2] of Object.entries(t2)) try {
            e2[n2] = s2;
          } catch {
            Object.defineProperty(e2, n2, { configurable: true, get: () => s2 });
          }
          return e2;
        }
        function On(e2) {
          if ("true" === e2) return true;
          if ("false" === e2) return false;
          if (e2 === Number(e2).toString()) return Number(e2);
          if ("" === e2 || "null" === e2) return null;
          if ("string" != typeof e2) return e2;
          try {
            return JSON.parse(decodeURIComponent(e2));
          } catch {
            return e2;
          }
        }
        function Ye(e2) {
          return e2.replace(/[A-Z]/g, (e3) => `-${e3.toLowerCase()}`);
        }
        const b = { setDataAttribute(e2, t2, n2) {
          e2.setAttribute(`data-bs-${Ye(t2)}`, n2);
        }, removeDataAttribute(e2, t2) {
          e2.removeAttribute(`data-bs-${Ye(t2)}`);
        }, getDataAttributes(e2) {
          if (!e2) return {};
          const t2 = {}, n2 = Object.keys(e2.dataset).filter((e3) => e3.startsWith("bs") && !e3.startsWith("bsConfig"));
          for (const o2 of n2) {
            let s2 = o2.replace(/^bs/, "");
            s2 = s2.charAt(0).toLowerCase() + s2.slice(1, s2.length), t2[s2] = On(e2.dataset[o2]);
          }
          return t2;
        }, getDataAttribute: (e2, t2) => On(e2.getAttribute(`data-bs-${Ye(t2)}`)) };
        class Q {
          static get Default() {
            return {};
          }
          static get DefaultType() {
            return {};
          }
          static get NAME() {
            throw new Error('You have to implement the static method "NAME", for each component!');
          }
          _getConfig(e2) {
            return e2 = this._mergeConfigObj(e2), e2 = this._configAfterMerge(e2), this._typeCheckConfig(e2), e2;
          }
          _configAfterMerge(e2) {
            return e2;
          }
          _mergeConfigObj(e2, t2) {
            const n2 = j(t2) ? b.getDataAttribute(t2, "config") : {};
            return { ...this.constructor.Default, ..."object" == typeof n2 ? n2 : {}, ...j(t2) ? b.getDataAttributes(t2) : {}, ..."object" == typeof e2 ? e2 : {} };
          }
          _typeCheckConfig(e2, t2 = this.constructor.DefaultType) {
            for (const [s2, o2] of Object.entries(t2)) {
              const i2 = e2[s2], a2 = j(i2) ? "element" : null == (n2 = i2) ? `${n2}` : Object.prototype.toString.call(n2).match(/\s([a-z]+)/i)[1].toLowerCase();
              if (!new RegExp(o2).test(a2)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s2}" provided type "${a2}" but expected type "${o2}".`);
            }
            var n2;
          }
        }
        class h extends Q {
          constructor(e2, t2) {
            super(), (e2 = x(e2)) && (this._element = e2, this._config = this._getConfig(t2), pt.set(this._element, this.constructor.DATA_KEY, this));
          }
          dispose() {
            pt.remove(this._element, this.constructor.DATA_KEY), e.off(this._element, this.constructor.EVENT_KEY);
            for (const e2 of Object.getOwnPropertyNames(this)) this[e2] = null;
          }
          _queueCallback(e2, t2, n2 = true) {
            Vt(e2, t2, n2);
          }
          _getConfig(e2) {
            return e2 = this._mergeConfigObj(e2, this._element), e2 = this._configAfterMerge(e2), this._typeCheckConfig(e2), e2;
          }
          static getInstance(e2) {
            return pt.get(x(e2), this.DATA_KEY);
          }
          static getOrCreateInstance(e2, t2 = {}) {
            return this.getInstance(e2) || new this(e2, "object" == typeof t2 ? t2 : null);
          }
          static get VERSION() {
            return "5.3.3";
          }
          static get DATA_KEY() {
            return `bs.${this.NAME}`;
          }
          static get EVENT_KEY() {
            return `.${this.DATA_KEY}`;
          }
          static eventName(e2) {
            return `${e2}${this.EVENT_KEY}`;
          }
        }
        const qe = (e2) => {
          let t2 = e2.getAttribute("data-bs-target");
          if (!t2 || "#" === t2) {
            let n2 = e2.getAttribute("href");
            if (!n2 || !n2.includes("#") && !n2.startsWith(".")) return null;
            n2.includes("#") && !n2.startsWith("#") && (n2 = `#${n2.split("#")[1]}`), t2 = n2 && "#" !== n2 ? n2.trim() : null;
          }
          return t2 ? t2.split(",").map((e3) => At(e3)).join(",") : null;
        }, t = { find: (e2, t2 = document.documentElement) => [].concat(...Element.prototype.querySelectorAll.call(t2, e2)), findOne: (e2, t2 = document.documentElement) => Element.prototype.querySelector.call(t2, e2), children: (e2, t2) => [].concat(...e2.children).filter((e3) => e3.matches(t2)), parents(e2, t2) {
          const s2 = [];
          let n2 = e2.parentNode.closest(t2);
          for (; n2; ) s2.push(n2), n2 = n2.parentNode.closest(t2);
          return s2;
        }, prev(e2, t2) {
          let n2 = e2.previousElementSibling;
          for (; n2; ) {
            if (n2.matches(t2)) return [n2];
            n2 = n2.previousElementSibling;
          }
          return [];
        }, next(e2, t2) {
          let n2 = e2.nextElementSibling;
          for (; n2; ) {
            if (n2.matches(t2)) return [n2];
            n2 = n2.nextElementSibling;
          }
          return [];
        }, focusableChildren(e2) {
          const t2 = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map((e3) => `${e3}:not([tabindex^="-"])`).join(",");
          return this.find(t2, e2).filter((e3) => !O(e3) && V(e3));
        }, getSelectorFromElement(e2) {
          const n2 = qe(e2);
          return n2 && t.findOne(n2) ? n2 : null;
        }, getElementFromSelector(e2) {
          const n2 = qe(e2);
          return n2 ? t.findOne(n2) : null;
        }, getMultipleElementsFromSelector(e2) {
          const n2 = qe(e2);
          return n2 ? t.find(n2) : [];
        } }, ve = (n2, s2 = "hide") => {
          const i2 = `click.dismiss${n2.EVENT_KEY}`, o2 = n2.NAME;
          e.on(document, i2, `[data-bs-dismiss="${o2}"]`, function(e2) {
            if (["A", "AREA"].includes(this.tagName) && e2.preventDefault(), O(this)) return;
            const i3 = t.getElementFromSelector(this) || this.closest(`.${o2}`);
            n2.getOrCreateInstance(i3)[s2]();
          });
        }, kn = ".bs.alert", to = `close${kn}`, Us = `closed${kn}`;
        class ue extends h {
          static get NAME() {
            return "alert";
          }
          close() {
            if (e.trigger(this._element, to).defaultPrevented) return;
            this._element.classList.remove("show");
            const t2 = this._element.classList.contains("fade");
            this._queueCallback(() => this._destroyElement(), this._element, t2);
          }
          _destroyElement() {
            this._element.remove(), e.trigger(this._element, Us), this.dispose();
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = ue.getOrCreateInstance(this);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2] || e2.startsWith("_") || "constructor" === e2) throw new TypeError(`No method named "${e2}"`);
                t2[e2](this);
              }
            });
          }
        }
        ve(ue, "close"), u(ue);
        const Hn = '[data-bs-toggle="button"]';
        class be extends h {
          static get NAME() {
            return "button";
          }
          toggle() {
            this._element.setAttribute("aria-pressed", this._element.classList.toggle("active"));
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = be.getOrCreateInstance(this);
              "toggle" === e2 && t2[e2]();
            });
          }
        }
        e.on(document, "click.bs.button.data-api", Hn, (e2) => {
          e2.preventDefault();
          const t2 = e2.target.closest(Hn);
          be.getOrCreateInstance(t2).toggle();
        }), u(be);
        const X = ".bs.swipe", ks = `touchstart${X}`, xs = `touchmove${X}`, us = `touchend${X}`, ds = `pointerdown${X}`, cs = `pointerup${X}`, os = { endCallback: null, leftCallback: null, rightCallback: null }, ls = { endCallback: "(function|null)", leftCallback: "(function|null)", rightCallback: "(function|null)" };
        class $e extends Q {
          constructor(e2, t2) {
            super(), this._element = e2, e2 && $e.isSupported() && (this._config = this._getConfig(t2), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents());
          }
          static get Default() {
            return os;
          }
          static get DefaultType() {
            return ls;
          }
          static get NAME() {
            return "swipe";
          }
          dispose() {
            e.off(this._element, X);
          }
          _start(e2) {
            this._supportPointerEvents ? this._eventIsPointerPenTouch(e2) && (this._deltaX = e2.clientX) : this._deltaX = e2.touches[0].clientX;
          }
          _end(e2) {
            this._eventIsPointerPenTouch(e2) && (this._deltaX = e2.clientX - this._deltaX), this._handleSwipe(), o(this._config.endCallback);
          }
          _move(e2) {
            this._deltaX = e2.touches && e2.touches.length > 1 ? 0 : e2.touches[0].clientX - this._deltaX;
          }
          _handleSwipe() {
            const e2 = Math.abs(this._deltaX);
            if (e2 <= 40) return;
            const t2 = e2 / this._deltaX;
            this._deltaX = 0, t2 && o(t2 > 0 ? this._config.rightCallback : this._config.leftCallback);
          }
          _initEvents() {
            this._supportPointerEvents ? (e.on(this._element, ds, (e2) => this._start(e2)), e.on(this._element, cs, (e2) => this._end(e2)), this._element.classList.add("pointer-event")) : (e.on(this._element, ks, (e2) => this._start(e2)), e.on(this._element, xs, (e2) => this._move(e2)), e.on(this._element, us, (e2) => this._end(e2)));
          }
          _eventIsPointerPenTouch(e2) {
            return this._supportPointerEvents && ("pen" === e2.pointerType || "touch" === e2.pointerType);
          }
          static isSupported() {
            return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0;
          }
        }
        const _ = ".bs.carousel", Ln = ".data-api", re = "next", W = "prev", $ = "left", de = "right", zs = `slide${_}`, Ve = `slid${_}`, Ds = `keydown${_}`, es = `mouseenter${_}`, ao = `mouseleave${_}`, fo = `dragstart${_}`, jo = `load${_}${Ln}`, yo = `click${_}${Ln}`, dn = "carousel", ye = "active", nn = ".active", tn = ".carousel-item", Ro = nn + tn, Po = { ArrowLeft: de, ArrowRight: $ }, Ho = { interval: 5e3, keyboard: true, pause: "hover", ride: false, touch: true, wrap: true }, Io = { interval: "(number|boolean)", keyboard: "boolean", pause: "(string|boolean)", ride: "(boolean|string)", touch: "boolean", wrap: "boolean" };
        class Z extends h {
          constructor(e2, n2) {
            super(e2, n2), this._interval = null, this._activeElement = null, this._isSliding = false, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = t.findOne(".carousel-indicators", this._element), this._addEventListeners(), this._config.ride === dn && this.cycle();
          }
          static get Default() {
            return Ho;
          }
          static get DefaultType() {
            return Io;
          }
          static get NAME() {
            return "carousel";
          }
          next() {
            this._slide(re);
          }
          nextWhenVisible() {
            !document.hidden && V(this._element) && this.next();
          }
          prev() {
            this._slide(W);
          }
          pause() {
            this._isSliding && zt(this._element), this._clearInterval();
          }
          cycle() {
            this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);
          }
          _maybeEnableCycle() {
            this._config.ride && (this._isSliding ? e.one(this._element, Ve, () => this.cycle()) : this.cycle());
          }
          to(t2) {
            const n2 = this._getItems();
            if (t2 > n2.length - 1 || t2 < 0) return;
            if (this._isSliding) return void e.one(this._element, Ve, () => this.to(t2));
            const s2 = this._getItemIndex(this._getActive());
            if (s2 === t2) return;
            const o2 = t2 > s2 ? re : W;
            this._slide(o2, n2[t2]);
          }
          dispose() {
            this._swipeHelper && this._swipeHelper.dispose(), super.dispose();
          }
          _configAfterMerge(e2) {
            return e2.defaultInterval = e2.interval, e2;
          }
          _addEventListeners() {
            this._config.keyboard && e.on(this._element, Ds, (e2) => this._keydown(e2)), "hover" === this._config.pause && (e.on(this._element, es, () => this.pause()), e.on(this._element, ao, () => this._maybeEnableCycle())), this._config.touch && $e.isSupported() && this._addTouchEventListeners();
          }
          _addTouchEventListeners() {
            for (const n3 of t.find(".carousel-item img", this._element)) e.on(n3, fo, (e2) => e2.preventDefault());
            const n2 = { leftCallback: () => this._slide(this._directionToOrder($)), rightCallback: () => this._slide(this._directionToOrder(de)), endCallback: () => {
              "hover" === this._config.pause && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), 500 + this._config.interval));
            } };
            this._swipeHelper = new $e(this._element, n2);
          }
          _keydown(e2) {
            if (/input|textarea/i.test(e2.target.tagName)) return;
            const t2 = Po[e2.key];
            t2 && (e2.preventDefault(), this._slide(this._directionToOrder(t2)));
          }
          _getItemIndex(e2) {
            return this._getItems().indexOf(e2);
          }
          _setActiveIndicatorElement(e2) {
            if (!this._indicatorsElement) return;
            const s2 = t.findOne(nn, this._indicatorsElement);
            s2.classList.remove(ye), s2.removeAttribute("aria-current");
            const n2 = t.findOne(`[data-bs-slide-to="${e2}"]`, this._indicatorsElement);
            n2 && (n2.classList.add(ye), n2.setAttribute("aria-current", "true"));
          }
          _updateInterval() {
            const e2 = this._activeElement || this._getActive();
            if (!e2) return;
            const t2 = Number.parseInt(e2.getAttribute("data-bs-interval"), 10);
            this._config.interval = t2 || this._config.defaultInterval;
          }
          _slide(t2, n2 = null) {
            if (this._isSliding) return;
            const o2 = this._getActive(), a2 = t2 === re, s2 = n2 || ht(this._getItems(), o2, a2, this._config.wrap);
            if (s2 === o2) return;
            const c2 = this._getItemIndex(s2), l2 = (n3) => e.trigger(this._element, n3, { relatedTarget: s2, direction: this._orderToDirection(t2), from: this._getItemIndex(o2), to: c2 });
            if (l2(zs).defaultPrevented) return;
            if (!o2 || !s2) return;
            const d2 = Boolean(this._interval);
            this.pause(), this._isSliding = true, this._setActiveIndicatorElement(c2), this._activeElement = s2;
            const i2 = a2 ? "carousel-item-start" : "carousel-item-end", r2 = a2 ? "carousel-item-next" : "carousel-item-prev";
            s2.classList.add(r2), oe(s2), o2.classList.add(i2), s2.classList.add(i2), this._queueCallback(() => {
              s2.classList.remove(i2, r2), s2.classList.add(ye), o2.classList.remove(ye, r2, i2), this._isSliding = false, l2(Ve);
            }, o2, this._isAnimated()), d2 && this.cycle();
          }
          _isAnimated() {
            return this._element.classList.contains("slide");
          }
          _getActive() {
            return t.findOne(Ro, this._element);
          }
          _getItems() {
            return t.find(tn, this._element);
          }
          _clearInterval() {
            this._interval && (clearInterval(this._interval), this._interval = null);
          }
          _directionToOrder(e2) {
            return d() ? e2 === $ ? W : re : e2 === $ ? re : W;
          }
          _orderToDirection(e2) {
            return d() ? e2 === W ? $ : de : e2 === W ? de : $;
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = Z.getOrCreateInstance(this, e2);
              if ("number" != typeof e2) {
                if ("string" == typeof e2) {
                  if (void 0 === t2[e2] || e2.startsWith("_") || "constructor" === e2) throw new TypeError(`No method named "${e2}"`);
                  t2[e2]();
                }
              } else t2.to(e2);
            });
          }
        }
        e.on(document, yo, "[data-bs-slide], [data-bs-slide-to]", function(e2) {
          const s2 = t.getElementFromSelector(this);
          if (!s2 || !s2.classList.contains(dn)) return;
          e2.preventDefault();
          const n2 = Z.getOrCreateInstance(s2), o2 = this.getAttribute("data-bs-slide-to");
          return o2 ? (n2.to(o2), void n2._maybeEnableCycle()) : "next" === b.getDataAttribute(this, "slide") ? (n2.next(), void n2._maybeEnableCycle()) : (n2.prev(), void n2._maybeEnableCycle());
        }), e.on(window, jo, () => {
          const e2 = t.find('[data-bs-ride="carousel"]');
          for (const t2 of e2) Z.getOrCreateInstance(t2);
        }), u(Z);
        const ie = ".bs.collapse", Bo = `show${ie}`, $o = `shown${ie}`, Uo = `hide${ie}`, Yo = `hidden${ie}`, Go = `click${ie}.data-api`, De = "show", L = "collapse", je = "collapsing", oi = `:scope .${L} .${L}`, Pe = '[data-bs-toggle="collapse"]', ii = { parent: null, toggle: true }, ai = { parent: "(null|element)", toggle: "boolean" };
        class ae extends h {
          constructor(e2, n2) {
            super(e2, n2), this._isTransitioning = false, this._triggerArray = [];
            const s2 = t.find(Pe);
            for (const e3 of s2) {
              const n3 = t.getSelectorFromElement(e3), o2 = t.find(n3).filter((e4) => e4 === this._element);
              null !== n3 && o2.length && this._triggerArray.push(e3);
            }
            this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle();
          }
          static get Default() {
            return ii;
          }
          static get DefaultType() {
            return ai;
          }
          static get NAME() {
            return "collapse";
          }
          toggle() {
            this._isShown() ? this.hide() : this.show();
          }
          show() {
            if (this._isTransitioning || this._isShown()) return;
            let n2 = [];
            if (this._config.parent && (n2 = this._getFirstLevelChildren(".collapse.show, .collapse.collapsing").filter((e2) => e2 !== this._element).map((e2) => ae.getOrCreateInstance(e2, { toggle: false }))), n2.length && n2[0]._isTransitioning) return;
            if (e.trigger(this._element, Bo).defaultPrevented) return;
            for (const e2 of n2) e2.hide();
            const t2 = this._getDimension();
            this._element.classList.remove(L), this._element.classList.add(je), this._element.style[t2] = 0, this._addAriaAndCollapsedClass(this._triggerArray, true), this._isTransitioning = true;
            const s2 = `scroll${t2[0].toUpperCase() + t2.slice(1)}`;
            this._queueCallback(() => {
              this._isTransitioning = false, this._element.classList.remove(je), this._element.classList.add(L, De), this._element.style[t2] = "", e.trigger(this._element, $o);
            }, this._element, true), this._element.style[t2] = `${this._element[s2]}px`;
          }
          hide() {
            if (this._isTransitioning || !this._isShown()) return;
            if (e.trigger(this._element, Uo).defaultPrevented) return;
            const n2 = this._getDimension();
            this._element.style[n2] = `${this._element.getBoundingClientRect()[n2]}px`, oe(this._element), this._element.classList.add(je), this._element.classList.remove(L, De);
            for (const e2 of this._triggerArray) {
              const n3 = t.getElementFromSelector(e2);
              n3 && !this._isShown(n3) && this._addAriaAndCollapsedClass([e2], false);
            }
            this._isTransitioning = true, this._element.style[n2] = "", this._queueCallback(() => {
              this._isTransitioning = false, this._element.classList.remove(je), this._element.classList.add(L), e.trigger(this._element, Yo);
            }, this._element, true);
          }
          _isShown(e2 = this._element) {
            return e2.classList.contains(De);
          }
          _configAfterMerge(e2) {
            return e2.toggle = Boolean(e2.toggle), e2.parent = x(e2.parent), e2;
          }
          _getDimension() {
            return this._element.classList.contains("collapse-horizontal") ? "width" : "height";
          }
          _initializeChildren() {
            if (!this._config.parent) return;
            const e2 = this._getFirstLevelChildren(Pe);
            for (const n2 of e2) {
              const s2 = t.getElementFromSelector(n2);
              s2 && this._addAriaAndCollapsedClass([n2], this._isShown(s2));
            }
          }
          _getFirstLevelChildren(e2) {
            const n2 = t.find(oi, this._config.parent);
            return t.find(e2, this._config.parent).filter((e3) => !n2.includes(e3));
          }
          _addAriaAndCollapsedClass(e2, t2) {
            if (e2.length) for (const n2 of e2) n2.classList.toggle("collapsed", !t2), n2.setAttribute("aria-expanded", t2);
          }
          static jQueryInterface(e2) {
            const t2 = {};
            return "string" == typeof e2 && /show|hide/.test(e2) && (t2.toggle = false), this.each(function() {
              const n2 = ae.getOrCreateInstance(this, t2);
              if ("string" == typeof e2) {
                if (void 0 === n2[e2]) throw new TypeError(`No method named "${e2}"`);
                n2[e2]();
              }
            });
          }
        }
        e.on(document, Go, Pe, function(e2) {
          ("A" === e2.target.tagName || e2.delegateTarget && "A" === e2.delegateTarget.tagName) && e2.preventDefault();
          for (const e3 of t.getMultipleElementsFromSelector(this)) ae.getOrCreateInstance(e3, { toggle: false }).toggle();
        }), u(ae);
        var Ht, J, Wt, Kt, Re, n = "top", a = "bottom", i = "right", s = "left", ge = "auto", D = [n, a, i, s], z = "start", U = "end", Tt = "clippingParents", Qe = "viewport", I = "popper", Mt = "reference", et = D.reduce(function(e2, t2) {
          return e2.concat([t2 + "-" + z, t2 + "-" + U]);
        }, []), tt = [].concat(D, [ge]).reduce(function(e2, t2) {
          return e2.concat([t2, t2 + "-" + z, t2 + "-" + U]);
        }, []), St = "beforeRead", kt = "read", Ct = "afterRead", xt = "beforeMain", wt = "main", _t = "afterMain", yt = "beforeWrite", jt = "write", bt = "afterWrite", Wn = [St, kt, Ct, xt, wt, _t, yt, jt, bt];
        function p(e2) {
          return e2 ? (e2.nodeName || "").toLowerCase() : null;
        }
        function r(e2) {
          if (e2 == null) return window;
          if ("[object Window]" !== e2.toString()) {
            var t2 = e2.ownerDocument;
            return t2 && t2.defaultView || window;
          }
          return e2;
        }
        function S(e2) {
          return e2 instanceof r(e2).Element || e2 instanceof Element;
        }
        function c(e2) {
          return e2 instanceof r(e2).HTMLElement || e2 instanceof HTMLElement;
        }
        function Je(e2) {
          return "undefined" != typeof ShadowRoot && (e2 instanceof r(e2).ShadowRoot || e2 instanceof ShadowRoot);
        }
        const ut = { name: "applyStyles", enabled: true, phase: "write", fn: function(e2) {
          var t2 = e2.state;
          Object.keys(t2.elements).forEach(function(e3) {
            var o2 = t2.styles[e3] || {}, s2 = t2.attributes[e3] || {}, n2 = t2.elements[e3];
            c(n2) && p(n2) && (Object.assign(n2.style, o2), Object.keys(s2).forEach(function(e4) {
              var t3 = s2[e4];
              false === t3 ? n2.removeAttribute(e4) : n2.setAttribute(e4, true === t3 ? "" : t3);
            }));
          });
        }, effect: function(e2) {
          var t2 = e2.state, n2 = { popper: { position: t2.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} };
          return Object.assign(t2.elements.popper.style, n2.popper), t2.styles = n2, t2.elements.arrow && Object.assign(t2.elements.arrow.style, n2.arrow), function() {
            Object.keys(t2.elements).forEach(function(e3) {
              var s2 = t2.elements[e3], o2 = t2.attributes[e3] || {}, i2 = Object.keys(t2.styles.hasOwnProperty(e3) ? t2.styles[e3] : n2[e3]).reduce(function(e4, t3) {
                return e4[t3] = "", e4;
              }, {});
              c(s2) && p(s2) && (Object.assign(s2.style, i2), Object.keys(o2).forEach(function(e4) {
                s2.removeAttribute(e4);
              }));
            });
          };
        }, requires: ["computeStyles"] };
        function f(e2) {
          return e2.split("-")[0];
        }
        var T = Math.max, xe = Math.min, q = Math.round;
        function at() {
          var e2 = navigator.userAgentData;
          return e2 != null && e2.brands && Array.isArray(e2.brands) ? e2.brands.map(function(e3) {
            return e3.brand + "/" + e3.version;
          }).join(" ") : navigator.userAgent;
        }
        function Ot() {
          return !/^((?!chrome|android).)*safari/i.test(at());
        }
        function Y(e2, t2, n2) {
          void 0 === t2 && (t2 = false), void 0 === n2 && (n2 = false);
          var s2 = e2.getBoundingClientRect(), i2 = 1, a2 = 1;
          t2 && c(e2) && (i2 = e2.offsetWidth > 0 && q(s2.width) / e2.offsetWidth || 1, a2 = e2.offsetHeight > 0 && q(s2.height) / e2.offsetHeight || 1);
          var o2 = (S(e2) ? r(e2) : window).visualViewport, u2 = !Ot() && n2, l2 = (s2.left + (u2 && o2 ? o2.offsetLeft : 0)) / i2, d2 = (s2.top + (u2 && o2 ? o2.offsetTop : 0)) / a2, h2 = s2.width / i2, m2 = s2.height / a2;
          return { width: h2, height: m2, top: d2, right: l2 + h2, bottom: d2 + m2, left: l2, x: l2, y: d2 };
        }
        function ot(e2) {
          var t2 = Y(e2), n2 = e2.offsetWidth, s2 = e2.offsetHeight;
          return Math.abs(t2.width - n2) <= 1 && (n2 = t2.width), Math.abs(t2.height - s2) <= 1 && (s2 = t2.height), { x: e2.offsetLeft, y: e2.offsetTop, width: n2, height: s2 };
        }
        function Et(e2, t2) {
          var n2, s2 = t2.getRootNode && t2.getRootNode();
          if (e2.contains(t2)) return true;
          if (s2 && Je(s2)) {
            n2 = t2;
            do {
              if (n2 && e2.isSameNode(n2)) return true;
              n2 = n2.parentNode || n2.host;
            } while (n2);
          }
          return false;
        }
        function v(e2) {
          return r(e2).getComputedStyle(e2);
        }
        function li(e2) {
          return ["table", "td", "th"].indexOf(p(e2)) >= 0;
        }
        function C(e2) {
          return ((S(e2) ? e2.ownerDocument : e2.document) || window.document).documentElement;
        }
        function ke(e2) {
          return "html" === p(e2) ? e2 : e2.assignedSlot || e2.parentNode || (Je(e2) ? e2.host : null) || C(e2);
        }
        function Ft(e2) {
          return c(e2) && "fixed" !== v(e2).position ? e2.offsetParent : null;
        }
        function ne(e2) {
          for (var n2 = r(e2), t2 = Ft(e2); t2 && li(t2) && "static" === v(t2).position; ) t2 = Ft(t2);
          return t2 && ("html" === p(t2) || "body" === p(t2) && "static" === v(t2).position) ? n2 : t2 || function(e3) {
            var t3, n3, s2 = /firefox/i.test(at());
            if (/Trident/i.test(at()) && c(e3) && "fixed" === v(e3).position) return null;
            t3 = ke(e3);
            for (Je(t3) && (t3 = t3.host); c(t3) && ["html", "body"].indexOf(p(t3)) < 0; ) {
              if (n3 = v(t3), "none" !== n3.transform || "none" !== n3.perspective || "paint" === n3.contain || -1 !== ["transform", "perspective"].indexOf(n3.willChange) || s2 && "filter" === n3.willChange || s2 && n3.filter && "none" !== n3.filter) return t3;
              t3 = t3.parentNode;
            }
            return null;
          }(e2) || n2;
        }
        function Ie(e2) {
          return ["top", "bottom"].indexOf(e2) >= 0 ? "x" : "y";
        }
        function se(e2, t2, n2) {
          return T(e2, xe(t2, n2));
        }
        function Nt(e2) {
          return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, e2);
        }
        function Lt(e2, t2) {
          return t2.reduce(function(t3, n2) {
            return t3[n2] = e2, t3;
          }, {});
        }
        const Rt = { name: "arrow", enabled: true, phase: "main", fn: function(e2) {
          var l2, t2 = e2.state, j2 = e2.name, k2 = e2.options, u2 = t2.elements.arrow, d2 = t2.modifiersData.popperOffsets, h2 = f(t2.placement), o2 = Ie(h2), r2 = [s, i].indexOf(h2) >= 0 ? "height" : "width";
          if (u2 && d2) {
            var p2 = function(e3, t3) {
              return Nt("number" != typeof (e3 = "function" == typeof e3 ? e3(Object.assign({}, t3.rects, { placement: t3.placement })) : e3) ? e3 : Lt(e3, D));
            }(k2.padding, t2), g2 = ot(u2), E2 = "y" === o2 ? n : s, w2 = "y" === o2 ? a : i, _2 = t2.rects.reference[r2] + t2.rects.reference[o2] - d2[o2] - t2.rects.popper[r2], y2 = d2[o2] - t2.rects.reference[o2], c2 = ne(u2), b2 = c2 ? "y" === o2 ? c2.clientHeight || 0 : c2.clientWidth || 0 : 0, O2 = _2 / 2 - y2 / 2, x2 = p2[E2], C2 = b2 - g2[r2] - p2[w2], v2 = b2 / 2 - g2[r2] / 2 + O2, m2 = se(x2, v2, C2), A2 = o2;
            t2.modifiersData[j2] = ((l2 = {})[A2] = m2, l2.centerOffset = m2 - v2, l2);
          }
        }, effect: function(e2) {
          var n2 = e2.state, s2 = e2.options.element, t2 = void 0 === s2 ? "[data-popper-arrow]" : s2;
          t2 != null && ("string" != typeof t2 || (t2 = n2.elements.popper.querySelector(t2))) && Et(n2.elements.popper, t2) && (n2.elements.arrow = t2);
        }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] };
        function H(e2) {
          return e2.split("-")[1];
        }
        Ht = { top: "auto", right: "auto", bottom: "auto", left: "auto" };
        function It(e2) {
          var h2, f2, b2, y2, u2 = e2.popper, T2 = e2.popperRect, l2 = e2.placement, S2 = e2.variation, m2 = e2.offsets, A2 = e2.position, g2 = e2.gpuAcceleration, w2 = e2.adaptive, j2 = e2.roundOffsets, k2 = e2.isFixed, D2 = m2.x, t2 = void 0 === D2 ? 0 : D2, z2 = m2.y, o2 = void 0 === z2 ? 0 : z2, E2 = "function" == typeof j2 ? j2({ x: t2, y: o2 }) : { x: t2, y: o2 }, t2 = E2.x, o2 = E2.y, O2 = m2.hasOwnProperty("x"), x2 = m2.hasOwnProperty("y"), p2 = s, _2 = n, c2 = window;
          if (w2) {
            var d2 = ne(u2), M2 = "clientHeight", F2 = "clientWidth";
            d2 === r(u2) && "static" !== v(d2 = C(u2)).position && "absolute" === A2 && (M2 = "scrollHeight", F2 = "scrollWidth"), (l2 === n || (l2 === s || l2 === i) && S2 === U) && (_2 = a, o2 -= (k2 && d2 === c2 && c2.visualViewport ? c2.visualViewport.height : d2[M2]) - T2.height, o2 *= g2 ? 1 : -1), l2 !== s && (l2 !== n && l2 !== a || S2 !== U) || (p2 = i, t2 -= (k2 && d2 === c2 && c2.visualViewport ? c2.visualViewport.width : d2[F2]) - T2.width, t2 *= g2 ? 1 : -1);
          }
          return y2 = Object.assign({ position: A2 }, w2 && Ht), b2 = true === j2 ? function(e3, t3) {
            var s2 = e3.x, o3 = e3.y, n2 = t3.devicePixelRatio || 1;
            return { x: q(s2 * n2) / n2 || 0, y: q(o3 * n2) / n2 || 0 };
          }({ x: t2, y: o2 }, r(u2)) : { x: t2, y: o2 }, t2 = b2.x, o2 = b2.y, g2 ? Object.assign({}, y2, ((h2 = {})[_2] = x2 ? "0" : "", h2[p2] = O2 ? "0" : "", h2.transform = (c2.devicePixelRatio || 1) <= 1 ? "translate(" + t2 + "px, " + o2 + "px)" : "translate3d(" + t2 + "px, " + o2 + "px, 0)", h2)) : Object.assign({}, y2, ((f2 = {})[_2] = x2 ? o2 + "px" : "", f2[p2] = O2 ? t2 + "px" : "", f2.transform = "", f2));
        }
        const ze = { name: "computeStyles", enabled: true, phase: "beforeWrite", fn: function(e2) {
          var t2 = e2.state, n2 = e2.options, s2 = n2.gpuAcceleration, c2 = void 0 === s2 || s2, o2 = n2.adaptive, l2 = void 0 === o2 || o2, i2 = n2.roundOffsets, a2 = void 0 === i2 || i2, r2 = { placement: f(t2.placement), variation: H(t2.placement), popper: t2.elements.popper, popperRect: t2.rects.popper, gpuAcceleration: c2, isFixed: "fixed" === t2.options.strategy };
          null != t2.modifiersData.popperOffsets && (t2.styles.popper = Object.assign({}, t2.styles.popper, It(Object.assign({}, r2, { offsets: t2.modifiersData.popperOffsets, position: t2.options.strategy, adaptive: l2, roundOffsets: a2 })))), null != t2.modifiersData.arrow && (t2.styles.arrow = Object.assign({}, t2.styles.arrow, It(Object.assign({}, r2, { offsets: t2.modifiersData.arrow, position: "absolute", adaptive: false, roundOffsets: a2 })))), t2.attributes.popper = Object.assign({}, t2.attributes.popper, { "data-popper-placement": t2.placement });
        }, data: {} };
        J = { passive: true };
        const Fe = { name: "eventListeners", enabled: true, phase: "write", fn: function() {
        }, effect: function(e2) {
          var n2 = e2.state, t2 = e2.instance, s2 = e2.options, o2 = s2.scroll, i2 = void 0 === o2 || o2, a2 = s2.resize, c2 = void 0 === a2 || a2, l2 = r(n2.elements.popper), d2 = [].concat(n2.scrollParents.reference, n2.scrollParents.popper);
          return i2 && d2.forEach(function(e3) {
            e3.addEventListener("scroll", t2.update, J);
          }), c2 && l2.addEventListener("resize", t2.update, J), function() {
            i2 && d2.forEach(function(e3) {
              e3.removeEventListener("scroll", t2.update, J);
            }), c2 && l2.removeEventListener("resize", t2.update, J);
          };
        }, data: {} };
        Wt = { left: "right", right: "left", bottom: "top", top: "bottom" };
        function Ee(e2) {
          return e2.replace(/left|right|bottom|top/g, function(e3) {
            return Wt[e3];
          });
        }
        Kt = { start: "end", end: "start" };
        function qt(e2) {
          return e2.replace(/start|end/g, function(e3) {
            return Kt[e3];
          });
        }
        function Se(e2) {
          var t2 = r(e2);
          return { scrollLeft: t2.pageXOffset, scrollTop: t2.pageYOffset };
        }
        function Me(e2) {
          return Y(C(e2)).left + Se(e2).scrollLeft;
        }
        function Te(e2) {
          var t2 = v(e2), n2 = t2.overflow, s2 = t2.overflowX, o2 = t2.overflowY;
          return /auto|scroll|overlay|hidden/.test(n2 + o2 + s2);
        }
        function Qt(e2) {
          return ["html", "body", "#document"].indexOf(p(e2)) >= 0 ? e2.ownerDocument.body : c(e2) && Te(e2) ? e2 : Qt(ke(e2));
        }
        function ee(e2, t2) {
          void 0 === t2 && (t2 = []);
          var s2, n2 = Qt(e2), o2 = n2 === (null == (s2 = e2.ownerDocument) ? void 0 : s2.body), i2 = r(n2), a2 = o2 ? [i2].concat(i2.visualViewport || [], Te(n2) ? n2 : []) : n2, c2 = t2.concat(a2);
          return o2 ? c2 : c2.concat(ee(ke(a2)));
        }
        function Ne(e2) {
          return Object.assign({}, e2, { left: e2.x, top: e2.y, right: e2.x + e2.width, bottom: e2.y + e2.height });
        }
        function en(e2, t2, n2) {
          return t2 === Qe ? Ne(function(e3, t3) {
            var s2, d2 = r(e3), o2 = C(e3), n3 = d2.visualViewport, i2 = o2.clientWidth, a2 = o2.clientHeight, c2 = 0, l2 = 0;
            return n3 && (i2 = n3.width, a2 = n3.height, s2 = Ot(), (s2 || !s2 && "fixed" === t3) && (c2 = n3.offsetLeft, l2 = n3.offsetTop)), { width: i2, height: a2, x: c2 + Me(e3), y: l2 };
          }(e2, n2)) : S(t2) ? function(e3, t3) {
            var n3 = Y(e3, false, "fixed" === t3);
            return n3.top = n3.top + e3.clientTop, n3.left = n3.left + e3.clientLeft, n3.bottom = n3.top + e3.clientHeight, n3.right = n3.left + e3.clientWidth, n3.width = e3.clientWidth, n3.height = e3.clientHeight, n3.x = n3.left, n3.y = n3.top, n3;
          }(t2, n2) : Ne(function(e3) {
            var s2, n3 = C(e3), o2 = Se(e3), t3 = null == (s2 = e3.ownerDocument) ? void 0 : s2.body, i2 = T(n3.scrollWidth, n3.clientWidth, t3 ? t3.scrollWidth : 0, t3 ? t3.clientWidth : 0), r2 = T(n3.scrollHeight, n3.clientHeight, t3 ? t3.scrollHeight : 0, t3 ? t3.clientHeight : 0), a2 = -o2.scrollLeft + Me(e3), c2 = -o2.scrollTop;
            return "rtl" === v(t3 || n3).direction && (a2 += T(n3.clientWidth, t3 ? t3.clientWidth : 0) - i2), { width: i2, height: r2, x: a2, y: c2 };
          }(C(e2)));
        }
        function gt(e2) {
          var o2, r2, l2, t2 = e2.reference, c2 = e2.element, d2 = e2.placement, u2 = d2 ? f(d2) : null, p2 = d2 ? H(d2) : null, h2 = t2.x + t2.width / 2 - c2.width / 2, m2 = t2.y + t2.height / 2 - c2.height / 2;
          switch (u2) {
            case n:
              o2 = { x: h2, y: t2.y - c2.height };
              break;
            case a:
              o2 = { x: h2, y: t2.y + t2.height };
              break;
            case i:
              o2 = { x: t2.x + t2.width, y: m2 };
              break;
            case s:
              o2 = { x: t2.x - c2.width, y: m2 };
              break;
            default:
              o2 = { x: t2.x, y: t2.y };
          }
          if (r2 = u2 ? Ie(u2) : null, r2 != null) switch (l2 = "y" === r2 ? "height" : "width", p2) {
            case z:
              o2[r2] = o2[r2] - (t2[l2] / 2 - c2[l2] / 2);
              break;
            case U:
              o2[r2] = o2[r2] + (t2[l2] / 2 - c2[l2] / 2);
          }
          return o2;
        }
        function R(e2, t2) {
          void 0 === t2 && (t2 = {});
          var x2, s2 = t2, y2 = s2.placement, w2 = void 0 === y2 ? e2.placement : y2, g2 = s2.strategy, P2 = void 0 === g2 ? e2.strategy : g2, b2 = s2.boundary, M2 = void 0 === b2 ? Tt : b2, k2 = s2.rootBoundary, R2 = void 0 === k2 ? Qe : k2, A2 = s2.elementContext, l2 = void 0 === A2 ? I : A2, f2 = s2.altBoundary, L2 = void 0 !== f2 && f2, _2 = s2.padding, u2 = void 0 === _2 ? 0 : _2, o2 = Nt("number" != typeof u2 ? u2 : Lt(u2, D)), N2 = l2 === I ? Mt : I, E2 = e2.rects.popper, m2 = e2.elements[L2 ? N2 : l2], r2 = function(e3, t3, n2, s3) {
            var a2 = "clippingParents" === t3 ? function(e4) {
              var n3 = ee(ke(e4)), t4 = ["absolute", "fixed"].indexOf(v(e4).position) >= 0 && c(e4) ? ne(e4) : e4;
              return S(t4) ? n3.filter(function(e5) {
                return S(e5) && Et(e5, t4) && "body" !== p(e5);
              }) : [];
            }(e3) : [].concat(t3), i2 = [].concat(a2, [n2]), r3 = i2[0], o3 = i2.reduce(function(t4, n3) {
              var o4 = en(e3, n3, s3);
              return t4.top = T(o4.top, t4.top), t4.right = xe(o4.right, t4.right), t4.bottom = xe(o4.bottom, t4.bottom), t4.left = T(o4.left, t4.left), t4;
            }, en(e3, r3, s3));
            return o3.width = o3.right - o3.left, o3.height = o3.bottom - o3.top, o3.x = o3.left, o3.y = o3.top, o3;
          }(S(m2) ? m2 : m2.contextElement || C(e2.elements.popper), M2, R2, P2), O2 = Y(e2.elements.reference), F2 = gt({ reference: O2, element: E2, strategy: "absolute", placement: w2 }), z2 = Ne(Object.assign({}, E2, F2)), d2 = l2 === I ? z2 : O2, h2 = { top: r2.top - d2.top + o2.top, bottom: d2.bottom - r2.bottom + o2.bottom, left: r2.left - d2.left + o2.left, right: d2.right - r2.right + o2.right }, j2 = e2.modifiersData.offset;
          return l2 === I && j2 && (x2 = j2[w2], Object.keys(h2).forEach(function(e3) {
            var t3 = [i, a].indexOf(e3) >= 0 ? 1 : -1, s3 = [n, a].indexOf(e3) >= 0 ? "y" : "x";
            h2[e3] += x2[s3] * t3;
          })), h2;
        }
        function No(e2, t2) {
          void 0 === t2 && (t2 = {});
          var s2, n2 = t2, c2 = n2.placement, l2 = n2.boundary, d2 = n2.rootBoundary, u2 = n2.padding, h2 = n2.flipVariations, i2 = n2.allowedAutoPlacements, m2 = void 0 === i2 ? tt : i2, a2 = H(c2), r2 = a2 ? h2 ? et : et.filter(function(e3) {
            return H(e3) === a2;
          }) : D, o2 = r2.filter(function(e3) {
            return m2.indexOf(e3) >= 0;
          });
          return 0 === o2.length && (o2 = r2), s2 = o2.reduce(function(t3, n3) {
            return t3[n3] = R(e2, { placement: n3, boundary: l2, rootBoundary: d2, padding: u2 })[f(n3)], t3;
          }, {}), Object.keys(s2).sort(function(e3, t3) {
            return s2[e3] - s2[t3];
          });
        }
        const on = { name: "flip", enabled: true, phase: "main", fn: function(e2) {
          var t2 = e2.state, o2 = e2.options, y2 = e2.name;
          if (!t2.modifiersData[y2]._skip) {
            for (var r2, d2, _2, O2, w2 = o2.mainAxis, I2 = void 0 === w2 || w2, C2 = o2.altAxis, D2 = void 0 === C2 || C2, N2 = o2.fallbackPlacements, j2 = o2.padding, b2 = o2.boundary, x2 = o2.rootBoundary, $2 = o2.altBoundary, S2 = o2.flipVariations, p2 = void 0 === S2 || S2, W2 = o2.allowedAutoPlacements, l2 = t2.options.placement, V2 = f(l2), B2 = N2 || (V2 !== l2 && p2 ? function(e3) {
              if (f(e3) === ge) return [];
              var t3 = Ee(e3);
              return [qt(e3), t3, qt(t3)];
            }(l2) : [Ee(l2)]), m2 = [l2].concat(B2).reduce(function(e3, n2) {
              return e3.concat(f(n2) === ge ? No(t2, { placement: n2, boundary: b2, rootBoundary: x2, padding: j2, flipVariations: p2, allowedAutoPlacements: W2 }) : n2);
            }, []), P2 = t2.rects.reference, L2 = t2.rects.popper, k2 = /* @__PURE__ */ new Map(), A2 = true, h2 = m2[0], v2 = 0; v2 < m2.length; v2++) {
              var c2 = m2[v2], T2 = f(c2), F2 = H(c2) === z, M2 = [n, a].indexOf(T2) >= 0, E2 = M2 ? "width" : "height", g2 = R(t2, { placement: c2, boundary: b2, rootBoundary: x2, altBoundary: $2, padding: j2 }), u2 = M2 ? F2 ? i : s : F2 ? a : n;
              if (P2[E2] > L2[E2] && (u2 = Ee(u2)), O2 = Ee(u2), r2 = [], I2 && r2.push(g2[T2] <= 0), D2 && r2.push(g2[u2] <= 0, g2[O2] <= 0), r2.every(function(e3) {
                return e3;
              })) {
                h2 = c2, A2 = false;
                break;
              }
              k2.set(c2, r2);
            }
            if (A2) for (_2 = function(e3) {
              var t3 = m2.find(function(t4) {
                var n2 = k2.get(t4);
                if (n2) return n2.slice(0, e3).every(function(e4) {
                  return e4;
                });
              });
              if (t3) return h2 = t3, "break";
            }, d2 = p2 ? 3 : 1; d2 > 0 && "break" !== _2(d2); d2--) ;
            t2.placement !== h2 && (t2.modifiersData[y2]._skip = true, t2.placement = h2, t2.reset = true);
          }
        }, requiresIfExists: ["offset"], data: { _skip: false } };
        function an(e2, t2, n2) {
          return void 0 === n2 && (n2 = { x: 0, y: 0 }), { top: e2.top - t2.height - n2.y, right: e2.right - t2.width + n2.x, bottom: e2.bottom - t2.height + n2.y, left: e2.left - t2.width - n2.x };
        }
        function rn(e2) {
          return [n, i, a, s].some(function(t2) {
            return e2[t2] >= 0;
          });
        }
        const cn = { name: "hide", enabled: true, phase: "main", requiresIfExists: ["preventOverflow"], fn: function(e2) {
          var t2 = e2.state, a2 = e2.name, r2 = t2.rects.reference, c2 = t2.rects.popper, l2 = t2.modifiersData.preventOverflow, d2 = R(t2, { elementContext: "reference" }), u2 = R(t2, { altBoundary: true }), n2 = an(d2, r2), s2 = an(u2, c2, l2), o2 = rn(n2), i2 = rn(s2);
          t2.modifiersData[a2] = { referenceClippingOffsets: n2, popperEscapeOffsets: s2, isReferenceHidden: o2, hasPopperEscaped: i2 }, t2.attributes.popper = Object.assign({}, t2.attributes.popper, { "data-popper-reference-hidden": o2, "data-popper-escaped": i2 });
        } }, ln = { name: "offset", enabled: true, phase: "main", requires: ["popperOffsets"], fn: function(e2) {
          var t2 = e2.state, c2 = e2.options, l2 = e2.name, o2 = c2.offset, d2 = void 0 === o2 ? [0, 0] : o2, a2 = tt.reduce(function(e3, o3) {
            return e3[o3] = function(e4, t3, o4) {
              var c3 = f(e4), d3 = [s, n].indexOf(c3) >= 0 ? -1 : 1, l3 = "function" == typeof o4 ? o4(Object.assign({}, t3, { placement: e4 })) : o4, a3 = l3[0], r3 = l3[1];
              return a3 = a3 || 0, r3 = (r3 || 0) * d3, [s, i].indexOf(c3) >= 0 ? { x: r3, y: a3 } : { x: a3, y: r3 };
            }(o3, t2.rects, d2), e3;
          }, {}), r2 = a2[t2.placement], u2 = r2.x, h2 = r2.y;
          null != t2.modifiersData.popperOffsets && (t2.modifiersData.popperOffsets.x += u2, t2.modifiersData.popperOffsets.y += h2), t2.modifiersData[l2] = a2;
        } }, Le = { name: "popperOffsets", enabled: true, phase: "read", fn: function(e2) {
          var t2 = e2.state, n2 = e2.name;
          t2.modifiersData[n2] = gt({ reference: t2.rects.reference, element: t2.rects.popper, strategy: "absolute", placement: t2.placement });
        }, data: {} }, un = { name: "preventOverflow", enabled: true, phase: "main", fn: function(e2) {
          var t2 = e2.state, c2 = e2.options, ge2 = e2.name, G2 = c2.mainAxis, he2 = void 0 === G2 || G2, oe2 = c2.altAxis, ie2 = void 0 !== oe2 && oe2, ve2 = c2.boundary, be2 = c2.rootBoundary, je2 = c2.altBoundary, ye2 = c2.padding, D2 = c2.tether, u2 = void 0 === D2 || D2, F2 = c2.tetherOffset, C2 = void 0 === F2 ? 0 : F2, _2 = R(t2, { boundary: ve2, rootBoundary: be2, padding: ye2, altBoundary: je2 }), M2 = f(t2.placement), x2 = H(t2.placement), J2 = !x2, o2 = Ie(M2), g2 = "x" === o2 ? "y" : "x", v2 = t2.modifiersData.popperOffsets, d2 = t2.rects.reference, p2 = t2.rects.popper, w2 = "function" == typeof C2 ? C2(Object.assign({}, t2.rects, { placement: t2.placement })) : C2, m2 = "number" == typeof w2 ? { mainAxis: w2, altAxis: w2 } : Object.assign({ mainAxis: 0, altAxis: 0 }, w2), y2 = t2.modifiersData.offset ? t2.modifiersData.offset[t2.placement] : null, E2 = { x: 0, y: 0 };
          if (v2) {
            if (he2) {
              var L2, A2 = "y" === o2 ? n : s, I2 = "y" === o2 ? a : i, r2 = "y" === o2 ? "height" : "width", h2 = v2[o2], $2 = h2 + _2[A2], W2 = h2 - _2[I2], S2 = u2 ? -p2[r2] / 2 : 0, pe2 = x2 === z ? d2[r2] : p2[r2], fe2 = x2 === z ? -p2[r2] : -d2[r2], Y2 = t2.elements.arrow, me2 = u2 && Y2 ? ot(Y2) : { width: 0, height: 0 }, X2 = t2.modifiersData["arrow#persistent"] ? t2.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, Q2 = X2[A2], Z2 = X2[I2], b2 = se(0, d2[r2], me2[r2]), le2 = J2 ? d2[r2] / 2 - S2 - b2 - Q2 - m2.mainAxis : pe2 - b2 - Q2 - m2.mainAxis, ce2 = J2 ? -d2[r2] / 2 + S2 + b2 + Z2 + m2.mainAxis : fe2 + b2 + Z2 + m2.mainAxis, O2 = t2.elements.arrow && ne(t2.elements.arrow), ae2 = O2 ? "y" === o2 ? O2.clientTop || 0 : O2.clientLeft || 0 : 0, U2 = null != (L2 = y2?.[o2]) ? L2 : 0, re2 = h2 + ce2 - U2, te2 = se(u2 ? xe($2, h2 + le2 - U2 - ae2) : $2, h2, u2 ? T(W2, re2) : W2);
              v2[o2] = te2, E2[o2] = te2 - h2;
            }
            if (ie2) {
              var ee2, de2 = "x" === o2 ? n : s, ue2 = "x" === o2 ? a : i, l2 = v2[g2], j2 = "y" === g2 ? "height" : "width", q2 = l2 + _2[de2], K2 = l2 - _2[ue2], k2 = -1 !== [n, s].indexOf(M2), V2 = null != (ee2 = y2?.[g2]) ? ee2 : 0, B2 = k2 ? q2 : l2 - d2[j2] - p2[j2] - V2 + m2.altAxis, P2 = k2 ? l2 + d2[j2] + p2[j2] - V2 - m2.altAxis : K2, N2 = u2 && k2 ? function(e3, t3, n2) {
                var s2 = se(e3, t3, n2);
                return s2 > n2 ? n2 : s2;
              }(B2, l2, P2) : se(u2 ? B2 : q2, l2, u2 ? P2 : K2);
              v2[g2] = N2, E2[g2] = N2 - l2;
            }
            t2.modifiersData[ge2] = E2;
          }
        }, requiresIfExists: ["offset"] };
        function Co(e2, t2, n2) {
          void 0 === n2 && (n2 = false);
          var s2, d2, u2 = c(t2), h2 = c(t2) && function(e3) {
            var t3 = e3.getBoundingClientRect(), n3 = q(t3.width) / e3.offsetWidth || 1, s3 = q(t3.height) / e3.offsetHeight || 1;
            return 1 !== n3 || 1 !== s3;
          }(t2), a2 = C(t2), i2 = Y(e2, h2, n2), l2 = { scrollLeft: 0, scrollTop: 0 }, o2 = { x: 0, y: 0 };
          return (u2 || !u2 && !n2) && (("body" !== p(t2) || Te(a2)) && (l2 = (s2 = t2) !== r(s2) && c(s2) ? { scrollLeft: (d2 = s2).scrollLeft, scrollTop: d2.scrollTop } : Se(s2)), c(t2) ? ((o2 = Y(t2, true)).x += t2.clientLeft, o2.y += t2.clientTop) : a2 && (o2.x = Me(a2))), { x: i2.left + l2.scrollLeft - o2.x, y: i2.top + l2.scrollTop - o2.y, width: i2.width, height: i2.height };
        }
        function _o(e2) {
          var n2 = /* @__PURE__ */ new Map(), t2 = /* @__PURE__ */ new Set(), s2 = [];
          function o2(e3) {
            t2.add(e3.name), [].concat(e3.requires || [], e3.requiresIfExists || []).forEach(function(e4) {
              if (!t2.has(e4)) {
                var s3 = n2.get(e4);
                s3 && o2(s3);
              }
            }), s2.push(e3);
          }
          return e2.forEach(function(e3) {
            n2.set(e3.name, e3);
          }), e2.forEach(function(e3) {
            t2.has(e3.name) || o2(e3);
          }), s2;
        }
        Re = { placement: "bottom", modifiers: [], strategy: "absolute" };
        function pn() {
          for (var t2 = arguments.length, n2 = new Array(t2), e2 = 0; e2 < t2; e2++) n2[e2] = arguments[e2];
          return !n2.some(function(e3) {
            return !e3 || "function" != typeof e3.getBoundingClientRect;
          });
        }
        function le(e2) {
          void 0 === e2 && (e2 = {});
          var n2 = e2, s2 = n2.defaultModifiers, i2 = void 0 === s2 ? [] : s2, o2 = n2.defaultOptions, t2 = void 0 === o2 ? Re : o2;
          return function(e3, n3, s3) {
            void 0 === s3 && (s3 = t2);
            var r2, d2, o3 = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, Re, t2), modifiersData: {}, elements: { reference: e3, popper: n3 }, attributes: {}, styles: {} }, c2 = [], l2 = false, a2 = { state: o3, setOptions: function(s4) {
              var r3, l3, d3, h2 = "function" == typeof s4 ? s4(o3.options) : s4;
              return u2(), o3.options = Object.assign({}, t2, o3.options, h2), o3.scrollParents = { reference: S(e3) ? ee(e3) : e3.contextElement ? ee(e3.contextElement) : [], popper: ee(n3) }, d3 = function(e4) {
                var t3 = _o(e4);
                return Wn.reduce(function(e5, n4) {
                  return e5.concat(t3.filter(function(e6) {
                    return e6.phase === n4;
                  }));
                }, []);
              }((l3 = [].concat(i2, o3.options.modifiers), r3 = l3.reduce(function(e4, t3) {
                var n4 = e4[t3.name];
                return e4[t3.name] = n4 ? Object.assign({}, n4, t3, { options: Object.assign({}, n4.options, t3.options), data: Object.assign({}, n4.data, t3.data) }) : t3, e4;
              }, {}), Object.keys(r3).map(function(e4) {
                return r3[e4];
              }))), o3.orderedModifiers = d3.filter(function(e4) {
                return e4.enabled;
              }), o3.orderedModifiers.forEach(function(e4) {
                var s5, i3 = e4.name, t3 = e4.options, r4 = void 0 === t3 ? {} : t3, n4 = e4.effect;
                "function" == typeof n4 && (s5 = n4({ state: o3, name: i3, instance: a2, options: r4 }), c2.push(s5 || function() {
                }));
              }), a2.update();
            }, forceUpdate: function() {
              if (!l2) {
                var s4 = o3.elements, i3 = s4.reference, t3 = s4.popper;
                if (pn(i3, t3)) {
                  o3.rects = { reference: Co(i3, ne(t3), "fixed" === o3.options.strategy), popper: ot(t3) }, o3.reset = false, o3.placement = o3.options.placement, o3.orderedModifiers.forEach(function(e5) {
                    return o3.modifiersData[e5.name] = Object.assign({}, e5.data);
                  });
                  for (e4 = 0; e4 < o3.orderedModifiers.length; e4++) if (true !== o3.reset) {
                    var e4, n4 = o3.orderedModifiers[e4], r3 = n4.fn, c3 = n4.options, d3 = void 0 === c3 ? {} : c3, u3 = n4.name;
                    "function" == typeof r3 && (o3 = r3({ state: o3, options: d3, name: u3, instance: a2 }) || o3);
                  } else o3.reset = false, e4 = -1;
                }
              }
            }, update: (d2 = function() {
              return new Promise(function(e4) {
                a2.forceUpdate(), e4(o3);
              });
            }, function() {
              return r2 || (r2 = new Promise(function(e4) {
                Promise.resolve().then(function() {
                  r2 = void 0, e4(d2());
                });
              })), r2;
            }), destroy: function() {
              u2(), l2 = true;
            } };
            if (!pn(e3, n3)) return a2;
            function u2() {
              c2.forEach(function(e4) {
                return e4();
              }), c2 = [];
            }
            return a2.setOptions(s3).then(function(e4) {
              !l2 && s3.onFirstUpdate && s3.onFirstUpdate(e4);
            }), a2;
          };
        }
        var vo = le(), po = le({ defaultModifiers: [Fe, Le, ze, ut] }), He = le({ defaultModifiers: [Fe, Le, ze, ut, ln, on, un, Rt, cn] });
        const yn = Object.freeze(Object.defineProperty({ __proto__: null, afterMain: _t, afterRead: Ct, afterWrite: bt, applyStyles: ut, arrow: Rt, auto: ge, basePlacements: D, beforeMain: xt, beforeRead: St, beforeWrite: yt, bottom: a, clippingParents: Tt, computeStyles: ze, createPopper: He, createPopperBase: vo, createPopperLite: po, detectOverflow: R, end: U, eventListeners: Fe, flip: on, hide: cn, left: s, main: wt, modifierPhases: Wn, offset: ln, placements: tt, popper: I, popperGenerator: le, popperOffsets: Le, preventOverflow: un, read: kt, reference: Mt, right: i, start: z, top: n, variationPlacements: et, viewport: Qe, write: jt }, Symbol.toStringTag, { value: "Module" })), _n = "dropdown", M = ".bs.dropdown", Be = ".data-api", oo = "ArrowUp", Cn = "ArrowDown", so = `hide${M}`, no = `hidden${M}`, Ks = `show${M}`, Hs = `shown${M}`, Mn = `click${M}${Be}`, Fn = `keydown${M}${Be}`, Ps = `keyup${M}${Be}`, B = "show", k = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)', Ts = `${k}.${B}`, fe = ".dropdown-menu", Fs = d() ? "top-end" : "top-start", Ss = d() ? "top-start" : "top-end", As = d() ? "bottom-end" : "bottom-start", Os = d() ? "bottom-start" : "bottom-end", ws = d() ? "left-start" : "right-start", ps = d() ? "right-start" : "left-start", fs = { autoClose: true, boundary: "clippingParents", display: "dynamic", offset: [0, 2], popperConfig: null, reference: "toggle" }, hs = { autoClose: "(boolean|string)", boundary: "(string|element)", display: "string", offset: "(array|string|function)", popperConfig: "(null|object|function)", reference: "(string|element|object)" };
        class m extends h {
          constructor(e2, n2) {
            super(e2, n2), this._popper = null, this._parent = this._element.parentNode, this._menu = t.next(this._element, fe)[0] || t.prev(this._element, fe)[0] || t.findOne(fe, this._parent), this._inNavbar = this._detectNavbar();
          }
          static get Default() {
            return fs;
          }
          static get DefaultType() {
            return hs;
          }
          static get NAME() {
            return _n;
          }
          toggle() {
            return this._isShown() ? this.hide() : this.show();
          }
          show() {
            if (O(this._element) || this._isShown()) return;
            const t2 = { relatedTarget: this._element };
            if (!e.trigger(this._element, Ks, t2).defaultPrevented) {
              if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(".navbar-nav")) for (const t3 of [].concat(...document.body.children)) e.on(t3, "mouseover", ce);
              this._element.focus(), this._element.setAttribute("aria-expanded", true), this._menu.classList.add(B), this._element.classList.add(B), e.trigger(this._element, Hs, t2);
            }
          }
          hide() {
            if (O(this._element) || !this._isShown()) return;
            const e2 = { relatedTarget: this._element };
            this._completeHide(e2);
          }
          dispose() {
            this._popper && this._popper.destroy(), super.dispose();
          }
          update() {
            this._inNavbar = this._detectNavbar(), this._popper && this._popper.update();
          }
          _completeHide(t2) {
            if (!e.trigger(this._element, so, t2).defaultPrevented) {
              if ("ontouchstart" in document.documentElement) for (const t3 of [].concat(...document.body.children)) e.off(t3, "mouseover", ce);
              this._popper && this._popper.destroy(), this._menu.classList.remove(B), this._element.classList.remove(B), this._element.setAttribute("aria-expanded", "false"), b.removeDataAttribute(this._menu, "popper"), e.trigger(this._element, no, t2);
            }
          }
          _getConfig(e2) {
            if ("object" == typeof (e2 = super._getConfig(e2)).reference && !j(e2.reference) && "function" != typeof e2.reference.getBoundingClientRect) throw new TypeError(`${_n.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
            return e2;
          }
          _createPopper() {
            if (void 0 === yn) throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
            let e2 = this._element;
            "parent" === this._config.reference ? e2 = this._parent : j(this._config.reference) ? e2 = x(this._config.reference) : "object" == typeof this._config.reference && (e2 = this._config.reference);
            const t2 = this._getPopperConfig();
            this._popper = He(e2, this._menu, t2);
          }
          _isShown() {
            return this._menu.classList.contains(B);
          }
          _getPlacement() {
            const e2 = this._parent;
            if (e2.classList.contains("dropend")) return ws;
            if (e2.classList.contains("dropstart")) return ps;
            if (e2.classList.contains("dropup-center")) return "top";
            if (e2.classList.contains("dropdown-center")) return "bottom";
            const t2 = "end" === getComputedStyle(this._menu).getPropertyValue("--bs-position").trim();
            return e2.classList.contains("dropup") ? t2 ? Ss : Fs : t2 ? Os : As;
          }
          _detectNavbar() {
            return null !== this._element.closest(".navbar");
          }
          _getOffset() {
            const { offset: e2 } = this._config;
            return "string" == typeof e2 ? e2.split(",").map((e3) => Number.parseInt(e3, 10)) : "function" == typeof e2 ? (t2) => e2(t2, this._element) : e2;
          }
          _getPopperConfig() {
            const e2 = { placement: this._getPlacement(), modifiers: [{ name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "offset", options: { offset: this._getOffset() } }] };
            return (this._inNavbar || "static" === this._config.display) && (b.setDataAttribute(this._menu, "popper", "static"), e2.modifiers = [{ name: "applyStyles", enabled: false }]), { ...e2, ...o(this._config.popperConfig, [e2]) };
          }
          _selectMenuItem({ key: e2, target: n2 }) {
            const s2 = t.find(".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)", this._menu).filter((e3) => V(e3));
            s2.length && ht(s2, n2, e2 === Cn, !s2.includes(n2)).focus();
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = m.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2]) throw new TypeError(`No method named "${e2}"`);
                t2[e2]();
              }
            });
          }
          static clearMenus(e2) {
            if (2 === e2.button || "keyup" === e2.type && "Tab" !== e2.key) return;
            const n2 = t.find(Ts);
            for (const a2 of n2) {
              const t2 = m.getInstance(a2);
              if (!t2 || false === t2._config.autoClose) continue;
              const s2 = e2.composedPath(), o2 = s2.includes(t2._menu);
              if (s2.includes(t2._element) || "inside" === t2._config.autoClose && !o2 || "outside" === t2._config.autoClose && o2) continue;
              if (t2._menu.contains(e2.target) && ("keyup" === e2.type && "Tab" === e2.key || /input|select|option|textarea|form/i.test(e2.target.tagName))) continue;
              const i2 = { relatedTarget: t2._element };
              "click" === e2.type && (i2.clickEvent = e2), t2._completeHide(i2);
            }
          }
          static dataApiKeydownHandler(e2) {
            const a2 = /input|textarea/i.test(e2.target.tagName), s2 = "Escape" === e2.key, o2 = [oo, Cn].includes(e2.key);
            if (!o2 && !s2) return;
            if (a2 && !s2) return;
            e2.preventDefault();
            const i2 = this.matches(k) ? this : t.prev(this, k)[0] || t.next(this, k)[0] || t.findOne(k, e2.delegateTarget.parentNode), n2 = m.getOrCreateInstance(i2);
            if (o2) return e2.stopPropagation(), n2.show(), void n2._selectMenuItem(e2);
            n2._isShown() && (e2.stopPropagation(), n2.hide(), i2.focus());
          }
        }
        e.on(document, Fn, k, m.dataApiKeydownHandler), e.on(document, Fn, fe, m.dataApiKeydownHandler), e.on(document, Mn, m.clearMenus), e.on(document, Ps, m.clearMenus), e.on(document, Mn, k, function(e2) {
          e2.preventDefault(), m.getOrCreateInstance(this).toggle();
        }), u(m);
        const Kn = "backdrop", qn = "show", Yn = `mousedown.bs.${Kn}`, rs = { className: "modal-backdrop", clickCallback: null, isAnimated: false, isVisible: true, rootElement: "body" }, is = { className: "string", clickCallback: "(function|null)", isAnimated: "boolean", isVisible: "boolean", rootElement: "(element|string)" };
        class Qn extends Q {
          constructor(e2) {
            super(), this._config = this._getConfig(e2), this._isAppended = false, this._element = null;
          }
          static get Default() {
            return rs;
          }
          static get DefaultType() {
            return is;
          }
          static get NAME() {
            return Kn;
          }
          show(e2) {
            if (!this._config.isVisible) return void o(e2);
            this._append();
            const t2 = this._getElement();
            this._config.isAnimated && oe(t2), t2.classList.add(qn), this._emulateAnimation(() => {
              o(e2);
            });
          }
          hide(e2) {
            this._config.isVisible ? (this._getElement().classList.remove(qn), this._emulateAnimation(() => {
              this.dispose(), o(e2);
            })) : o(e2);
          }
          dispose() {
            this._isAppended && (e.off(this._element, Yn), this._element.remove(), this._isAppended = false);
          }
          _getElement() {
            if (!this._element) {
              const e2 = document.createElement("div");
              e2.className = this._config.className, this._config.isAnimated && e2.classList.add("fade"), this._element = e2;
            }
            return this._element;
          }
          _configAfterMerge(e2) {
            return e2.rootElement = x(e2.rootElement), e2;
          }
          _append() {
            if (this._isAppended) return;
            const t2 = this._getElement();
            this._config.rootElement.append(t2), e.on(t2, Yn, () => {
              o(this._config.clickCallback);
            }), this._isAppended = true;
          }
          _emulateAnimation(e2) {
            Vt(e2, this._getElement(), this._config.isAnimated);
          }
        }
        const _e = ".bs.focustrap", ts = `focusin${_e}`, io = `keydown.tab${_e}`, vt = "backward", ns = { autofocus: true, trapElement: null }, ss = { autofocus: "boolean", trapElement: "element" };
        class Zn extends Q {
          constructor(e2) {
            super(), this._config = this._getConfig(e2), this._isActive = false, this._lastTabNavDirection = null;
          }
          static get Default() {
            return ns;
          }
          static get DefaultType() {
            return ss;
          }
          static get NAME() {
            return "focustrap";
          }
          activate() {
            this._isActive || (this._config.autofocus && this._config.trapElement.focus(), e.off(document, _e), e.on(document, ts, (e2) => this._handleFocusin(e2)), e.on(document, io, (e2) => this._handleKeydown(e2)), this._isActive = true);
          }
          deactivate() {
            this._isActive && (this._isActive = false, e.off(document, _e));
          }
          _handleFocusin(e2) {
            const { trapElement: n2 } = this._config;
            if (e2.target === document || e2.target === n2 || n2.contains(e2.target)) return;
            const s2 = t.focusableChildren(n2);
            0 === s2.length ? n2.focus() : this._lastTabNavDirection === vt ? s2[s2.length - 1].focus() : s2[0].focus();
          }
          _handleKeydown(e2) {
            "Tab" === e2.key && (this._lastTabNavDirection = e2.shiftKey ? vt : "forward");
          }
        }
        const Xn = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top", Gn = ".sticky-top", Oe = "padding-right", Un = "margin-right";
        class We {
          constructor() {
            this._element = document.body;
          }
          getWidth() {
            const e2 = document.documentElement.clientWidth;
            return Math.abs(window.innerWidth - e2);
          }
          hide() {
            const e2 = this.getWidth();
            this._disableOverFlow(), this._setElementAttributes(this._element, Oe, (t2) => t2 + e2), this._setElementAttributes(Xn, Oe, (t2) => t2 + e2), this._setElementAttributes(Gn, Un, (t2) => t2 - e2);
          }
          reset() {
            this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, Oe), this._resetElementAttributes(Xn, Oe), this._resetElementAttributes(Gn, Un);
          }
          isOverflowing() {
            return this.getWidth() > 0;
          }
          _disableOverFlow() {
            this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden";
          }
          _setElementAttributes(e2, t2, n2) {
            const s2 = this.getWidth();
            this._applyManipulationCallback(e2, (e3) => {
              if (e3 !== this._element && window.innerWidth > e3.clientWidth + s2) return;
              this._saveInitialAttribute(e3, t2);
              const o2 = window.getComputedStyle(e3).getPropertyValue(t2);
              e3.style.setProperty(t2, `${n2(Number.parseFloat(o2))}px`);
            });
          }
          _saveInitialAttribute(e2, t2) {
            const n2 = e2.style.getPropertyValue(t2);
            n2 && b.setDataAttribute(e2, t2, n2);
          }
          _resetElementAttributes(e2, t2) {
            this._applyManipulationCallback(e2, (e3) => {
              const n2 = b.getDataAttribute(e3, t2);
              null !== n2 ? (b.removeDataAttribute(e3, t2), e3.style.setProperty(t2, n2)) : e3.style.removeProperty(t2);
            });
          }
          _applyManipulationCallback(e2, n2) {
            if (j(e2)) n2(e2);
            else for (const s2 of t.find(e2, this._element)) n2(s2);
          }
        }
        const l = ".bs.modal", Jn = `hide${l}`, ms = `hidePrevented${l}`, $n = `hidden${l}`, Vn = `show${l}`, gs = `shown${l}`, vs = `resize${l}`, bs = `click.dismiss${l}`, js = `mousedown.dismiss${l}`, ys = `keydown.dismiss${l}`, _s = `click${l}.data-api`, Bn = "modal-open", In = "show", Ue = "modal-static", Cs = { backdrop: true, focus: true, keyboard: true }, Es = { backdrop: "(boolean|string)", focus: "boolean", keyboard: "boolean" };
        class G extends h {
          constructor(e2, n2) {
            super(e2, n2), this._dialog = t.findOne(".modal-dialog", this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = false, this._isTransitioning = false, this._scrollBar = new We(), this._addEventListeners();
          }
          static get Default() {
            return Cs;
          }
          static get DefaultType() {
            return Es;
          }
          static get NAME() {
            return "modal";
          }
          toggle(e2) {
            return this._isShown ? this.hide() : this.show(e2);
          }
          show(t2) {
            this._isShown || this._isTransitioning || e.trigger(this._element, Vn, { relatedTarget: t2 }).defaultPrevented || (this._isShown = true, this._isTransitioning = true, this._scrollBar.hide(), document.body.classList.add(Bn), this._adjustDialog(), this._backdrop.show(() => this._showElement(t2)));
          }
          hide() {
            this._isShown && !this._isTransitioning && (e.trigger(this._element, Jn).defaultPrevented || (this._isShown = false, this._isTransitioning = true, this._focustrap.deactivate(), this._element.classList.remove(In), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated())));
          }
          dispose() {
            e.off(window, l), e.off(this._dialog, l), this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
          }
          handleUpdate() {
            this._adjustDialog();
          }
          _initializeBackDrop() {
            return new Qn({ isVisible: Boolean(this._config.backdrop), isAnimated: this._isAnimated() });
          }
          _initializeFocusTrap() {
            return new Zn({ trapElement: this._element });
          }
          _showElement(n2) {
            document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
            const s2 = t.findOne(".modal-body", this._dialog);
            s2 && (s2.scrollTop = 0), oe(this._element), this._element.classList.add(In), this._queueCallback(() => {
              this._config.focus && this._focustrap.activate(), this._isTransitioning = false, e.trigger(this._element, gs, { relatedTarget: n2 });
            }, this._dialog, this._isAnimated());
          }
          _addEventListeners() {
            e.on(this._element, ys, (e2) => {
              "Escape" === e2.key && (this._config.keyboard ? this.hide() : this._triggerBackdropTransition());
            }), e.on(window, vs, () => {
              this._isShown && !this._isTransitioning && this._adjustDialog();
            }), e.on(this._element, js, (t2) => {
              e.one(this._element, bs, (e2) => {
                this._element === t2.target && this._element === e2.target && ("static" !== this._config.backdrop ? this._config.backdrop && this.hide() : this._triggerBackdropTransition());
              });
            });
          }
          _hideModal() {
            this._element.style.display = "none", this._element.setAttribute("aria-hidden", true), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = false, this._backdrop.hide(() => {
              document.body.classList.remove(Bn), this._resetAdjustments(), this._scrollBar.reset(), e.trigger(this._element, $n);
            });
          }
          _isAnimated() {
            return this._element.classList.contains("fade");
          }
          _triggerBackdropTransition() {
            if (e.trigger(this._element, ms).defaultPrevented) return;
            const n2 = this._element.scrollHeight > document.documentElement.clientHeight, t2 = this._element.style.overflowY;
            "hidden" === t2 || this._element.classList.contains(Ue) || (n2 || (this._element.style.overflowY = "hidden"), this._element.classList.add(Ue), this._queueCallback(() => {
              this._element.classList.remove(Ue), this._queueCallback(() => {
                this._element.style.overflowY = t2;
              }, this._dialog);
            }, this._dialog), this._element.focus());
          }
          _adjustDialog() {
            const t2 = this._element.scrollHeight > document.documentElement.clientHeight, e2 = this._scrollBar.getWidth(), n2 = e2 > 0;
            if (n2 && !t2) {
              const t3 = d() ? "paddingLeft" : "paddingRight";
              this._element.style[t3] = `${e2}px`;
            }
            if (!n2 && t2) {
              const t3 = d() ? "paddingRight" : "paddingLeft";
              this._element.style[t3] = `${e2}px`;
            }
          }
          _resetAdjustments() {
            this._element.style.paddingLeft = "", this._element.style.paddingRight = "";
          }
          static jQueryInterface(e2, t2) {
            return this.each(function() {
              const n2 = G.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === n2[e2]) throw new TypeError(`No method named "${e2}"`);
                n2[e2](t2);
              }
            });
          }
        }
        e.on(document, _s, '[data-bs-toggle="modal"]', function(n2) {
          const s2 = t.getElementFromSelector(this);
          ["A", "AREA"].includes(this.tagName) && n2.preventDefault(), e.one(s2, Vn, (t2) => {
            t2.defaultPrevented || e.one(s2, $n, () => {
              V(this) && this.focus();
            });
          });
          const o2 = t.findOne(".modal.show");
          o2 && G.getInstance(o2).hide(), G.getOrCreateInstance(s2).toggle(this);
        }), ve(G), u(G);
        const g = ".bs.offcanvas", Pn = ".data-api", Ms = `load${g}${Pn}`, Rn = "show", Nn = "showing", Dn = "hiding", zn = ".offcanvas.show", Ns = `show${g}`, Ls = `shown${g}`, Rs = `hide${g}`, Tn = `hidePrevented${g}`, Sn = `hidden${g}`, Is = `resize${g}`, Bs = `click${g}${Pn}`, Vs = `keydown.dismiss${g}`, $s = { backdrop: true, keyboard: true, scroll: false }, Ws = { backdrop: "(boolean|string)", keyboard: "boolean", scroll: "boolean" };
        class E extends h {
          constructor(e2, t2) {
            super(e2, t2), this._isShown = false, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners();
          }
          static get Default() {
            return $s;
          }
          static get DefaultType() {
            return Ws;
          }
          static get NAME() {
            return "offcanvas";
          }
          toggle(e2) {
            return this._isShown ? this.hide() : this.show(e2);
          }
          show(t2) {
            this._isShown || e.trigger(this._element, Ns, { relatedTarget: t2 }).defaultPrevented || (this._isShown = true, this._backdrop.show(), this._config.scroll || new We().hide(), this._element.setAttribute("aria-modal", true), this._element.setAttribute("role", "dialog"), this._element.classList.add(Nn), this._queueCallback(() => {
              this._config.scroll && !this._config.backdrop || this._focustrap.activate(), this._element.classList.add(Rn), this._element.classList.remove(Nn), e.trigger(this._element, Ls, { relatedTarget: t2 });
            }, this._element, true));
          }
          hide() {
            this._isShown && (e.trigger(this._element, Rs).defaultPrevented || (this._focustrap.deactivate(), this._element.blur(), this._isShown = false, this._element.classList.add(Dn), this._backdrop.hide(), this._queueCallback(() => {
              this._element.classList.remove(Rn, Dn), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new We().reset(), e.trigger(this._element, Sn);
            }, this._element, true)));
          }
          dispose() {
            this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose();
          }
          _initializeBackDrop() {
            const t2 = Boolean(this._config.backdrop);
            return new Qn({ className: "offcanvas-backdrop", isVisible: t2, isAnimated: true, rootElement: this._element.parentNode, clickCallback: t2 ? () => {
              "static" !== this._config.backdrop ? this.hide() : e.trigger(this._element, Tn);
            } : null });
          }
          _initializeFocusTrap() {
            return new Zn({ trapElement: this._element });
          }
          _addEventListeners() {
            e.on(this._element, Vs, (t2) => {
              "Escape" === t2.key && (this._config.keyboard ? this.hide() : e.trigger(this._element, Tn));
            });
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = E.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2] || e2.startsWith("_") || "constructor" === e2) throw new TypeError(`No method named "${e2}"`);
                t2[e2](this);
              }
            });
          }
        }
        e.on(document, Bs, '[data-bs-toggle="offcanvas"]', function(n2) {
          const s2 = t.getElementFromSelector(this);
          if (["A", "AREA"].includes(this.tagName) && n2.preventDefault(), O(this)) return;
          e.one(s2, Sn, () => {
            V(this) && this.focus();
          });
          const o2 = t.findOne(zn);
          o2 && o2 !== s2 && E.getInstance(o2).hide(), E.getOrCreateInstance(s2).toggle(this);
        }), e.on(window, Ms, () => {
          for (const e2 of t.find(zn)) E.getOrCreateInstance(e2).show();
        }), e.on(window, Is, () => {
          for (const e2 of t.find("[aria-modal][class*=show][class*=offcanvas-]")) "fixed" !== getComputedStyle(e2).position && E.getOrCreateInstance(e2).hide();
        }), ve(E), u(E);
        const An = { "*": ["class", "dir", "id", "lang", "role", /^aria-[\w-]*$/i], a: ["target", "href", "title", "rel"], area: [], b: [], br: [], col: [], code: [], dd: [], div: [], dl: [], dt: [], em: [], hr: [], h1: [], h2: [], h3: [], h4: [], h5: [], h6: [], i: [], img: ["src", "srcset", "alt", "title", "width", "height"], li: [], ol: [], p: [], pre: [], s: [], small: [], span: [], sub: [], sup: [], strong: [], u: [], ul: [] }, qs = /* @__PURE__ */ new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]), Ys = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i, Gs = (e2, t2) => {
          const n2 = e2.nodeName.toLowerCase();
          return t2.includes(n2) ? !qs.has(n2) || Boolean(Ys.test(e2.nodeValue)) : t2.filter((e3) => e3 instanceof RegExp).some((e3) => e3.test(n2));
        }, Xs = { allowList: An, content: {}, extraClass: "", html: false, sanitize: true, sanitizeFn: null, template: "<div></div>" }, Qs = { allowList: "object", content: "object", extraClass: "(string|function)", html: "boolean", sanitize: "boolean", sanitizeFn: "(null|function)", template: "string" }, Zs = { entry: "(string|element|function|null)", selector: "(string|element)" };
        class Js extends Q {
          constructor(e2) {
            super(), this._config = this._getConfig(e2);
          }
          static get Default() {
            return Xs;
          }
          static get DefaultType() {
            return Qs;
          }
          static get NAME() {
            return "TemplateFactory";
          }
          getContent() {
            return Object.values(this._config.content).map((e2) => this._resolvePossibleFunction(e2)).filter(Boolean);
          }
          hasContent() {
            return this.getContent().length > 0;
          }
          changeContent(e2) {
            return this._checkContent(e2), this._config.content = { ...this._config.content, ...e2 }, this;
          }
          toHtml() {
            const e2 = document.createElement("div");
            e2.innerHTML = this._maybeSanitize(this._config.template);
            for (const [t3, n3] of Object.entries(this._config.content)) this._setContent(e2, n3, t3);
            const t2 = e2.children[0], n2 = this._resolvePossibleFunction(this._config.extraClass);
            return n2 && t2.classList.add(...n2.split(" ")), t2;
          }
          _typeCheckConfig(e2) {
            super._typeCheckConfig(e2), this._checkContent(e2.content);
          }
          _checkContent(e2) {
            for (const [t2, n2] of Object.entries(e2)) super._typeCheckConfig({ selector: t2, entry: n2 }, Zs);
          }
          _setContent(e2, n2, s2) {
            const o2 = t.findOne(s2, e2);
            o2 && ((n2 = this._resolvePossibleFunction(n2)) ? j(n2) ? this._putElementInTemplate(x(n2), o2) : this._config.html ? o2.innerHTML = this._maybeSanitize(n2) : o2.textContent = n2 : o2.remove());
          }
          _maybeSanitize(e2) {
            return this._config.sanitize ? function(e3, t2, n2) {
              if (!e3.length) return e3;
              if (n2 && "function" == typeof n2) return n2(e3);
              const s2 = new window.DOMParser().parseFromString(e3, "text/html"), o2 = [].concat(...s2.body.querySelectorAll("*"));
              for (const e4 of o2) {
                const n3 = e4.nodeName.toLowerCase();
                if (!Object.keys(t2).includes(n3)) {
                  e4.remove();
                  continue;
                }
                const s3 = [].concat(...e4.attributes), i2 = [].concat(t2["*"] || [], t2[n3] || []);
                for (const t3 of s3) Gs(t3, i2) || e4.removeAttribute(t3.nodeName);
              }
              return s2.body.innerHTML;
            }(e2, this._config.allowList, this._config.sanitizeFn) : e2;
          }
          _resolvePossibleFunction(e2) {
            return o(e2, [this]);
          }
          _putElementInTemplate(e2, t2) {
            if (this._config.html) return t2.innerHTML = "", void t2.append(e2);
            t2.textContent = e2.textContent;
          }
        }
        const eo = /* @__PURE__ */ new Set(["sanitize", "allowList", "sanitizeFn"]), Ke = "fade", he = "show", En = ".modal", xn = "hide.bs.modal", te = "hover", Xe = "focus", ro = { AUTO: "auto", TOP: "top", RIGHT: d() ? "left" : "right", BOTTOM: "bottom", LEFT: d() ? "right" : "left" }, co = { allowList: An, animation: true, boundary: "clippingParents", container: false, customClass: "", delay: 0, fallbackPlacements: ["top", "right", "bottom", "left"], html: false, offset: [0, 6], placement: "top", popperConfig: null, sanitize: true, sanitizeFn: null, selector: false, template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>', title: "", trigger: "hover focus" }, lo = { allowList: "object", animation: "boolean", boundary: "(string|element)", container: "(string|element|boolean)", customClass: "(string|function)", delay: "(number|object)", fallbackPlacements: "array", html: "boolean", offset: "(array|string|function)", placement: "(string|function)", popperConfig: "(null|object|function)", sanitize: "boolean", sanitizeFn: "(null|function)", selector: "(string|boolean)", template: "string", title: "(string|element|function)", trigger: "string" };
        class P extends h {
          constructor(e2, t2) {
            if (void 0 === yn) throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
            super(e2, t2), this._isEnabled = true, this._timeout = 0, this._isHovered = null, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners(), this._config.selector || this._fixTitle();
          }
          static get Default() {
            return co;
          }
          static get DefaultType() {
            return lo;
          }
          static get NAME() {
            return "tooltip";
          }
          enable() {
            this._isEnabled = true;
          }
          disable() {
            this._isEnabled = false;
          }
          toggleEnabled() {
            this._isEnabled = !this._isEnabled;
          }
          toggle() {
            this._isEnabled && (this._activeTrigger.click = !this._activeTrigger.click, this._isShown() ? this._leave() : this._enter());
          }
          dispose() {
            clearTimeout(this._timeout), e.off(this._element.closest(En), xn, this._hideModalHandler), this._element.getAttribute("data-bs-original-title") && this._element.setAttribute("title", this._element.getAttribute("data-bs-original-title")), this._disposePopper(), super.dispose();
          }
          show() {
            if ("none" === this._element.style.display) throw new Error("Please use show on visible elements");
            if (!this._isWithContent() || !this._isEnabled) return;
            const n2 = e.trigger(this._element, this.constructor.eventName("show")), s2 = (Dt(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
            if (n2.defaultPrevented || !s2) return;
            this._disposePopper();
            const t2 = this._getTipElement();
            this._element.setAttribute("aria-describedby", t2.getAttribute("id"));
            const { container: o2 } = this._config;
            if (this._element.ownerDocument.documentElement.contains(this.tip) || (o2.append(t2), e.trigger(this._element, this.constructor.eventName("inserted"))), this._popper = this._createPopper(t2), t2.classList.add(he), "ontouchstart" in document.documentElement) for (const t3 of [].concat(...document.body.children)) e.on(t3, "mouseover", ce);
            this._queueCallback(() => {
              e.trigger(this._element, this.constructor.eventName("shown")), false === this._isHovered && this._leave(), this._isHovered = false;
            }, this.tip, this._isAnimated());
          }
          hide() {
            if (this._isShown() && !e.trigger(this._element, this.constructor.eventName("hide")).defaultPrevented) {
              if (this._getTipElement().classList.remove(he), "ontouchstart" in document.documentElement) for (const t2 of [].concat(...document.body.children)) e.off(t2, "mouseover", ce);
              this._activeTrigger.click = false, this._activeTrigger[Xe] = false, this._activeTrigger[te] = false, this._isHovered = null, this._queueCallback(() => {
                this._isWithActiveTrigger() || (this._isHovered || this._disposePopper(), this._element.removeAttribute("aria-describedby"), e.trigger(this._element, this.constructor.eventName("hidden")));
              }, this.tip, this._isAnimated());
            }
          }
          update() {
            this._popper && this._popper.update();
          }
          _isWithContent() {
            return Boolean(this._getTitle());
          }
          _getTipElement() {
            return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip;
          }
          _createTipElement(e2) {
            const t2 = this._getTemplateFactory(e2).toHtml();
            if (!t2) return null;
            t2.classList.remove(Ke, he), t2.classList.add(`bs-${this.constructor.NAME}-auto`);
            const n2 = ((e3) => {
              do
                e3 += Math.floor(1e6 * Math.random());
              while (document.getElementById(e3));
              return e3;
            })(this.constructor.NAME).toString();
            return t2.setAttribute("id", n2), this._isAnimated() && t2.classList.add(Ke), t2;
          }
          setContent(e2) {
            this._newContent = e2, this._isShown() && (this._disposePopper(), this.show());
          }
          _getTemplateFactory(e2) {
            return this._templateFactory ? this._templateFactory.changeContent(e2) : this._templateFactory = new Js({ ...this._config, content: e2, extraClass: this._resolvePossibleFunction(this._config.customClass) }), this._templateFactory;
          }
          _getContentForTemplate() {
            return { ".tooltip-inner": this._getTitle() };
          }
          _getTitle() {
            return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute("data-bs-original-title");
          }
          _initializeOnDelegatedTarget(e2) {
            return this.constructor.getOrCreateInstance(e2.delegateTarget, this._getDelegateConfig());
          }
          _isAnimated() {
            return this._config.animation || this.tip && this.tip.classList.contains(Ke);
          }
          _isShown() {
            return this.tip && this.tip.classList.contains(he);
          }
          _createPopper(e2) {
            const t2 = o(this._config.placement, [this, e2, this._element]), n2 = ro[t2.toUpperCase()];
            return He(this._element, e2, this._getPopperConfig(n2));
          }
          _getOffset() {
            const { offset: e2 } = this._config;
            return "string" == typeof e2 ? e2.split(",").map((e3) => Number.parseInt(e3, 10)) : "function" == typeof e2 ? (t2) => e2(t2, this._element) : e2;
          }
          _resolvePossibleFunction(e2) {
            return o(e2, [this._element]);
          }
          _getPopperConfig(e2) {
            const t2 = { placement: e2, modifiers: [{ name: "flip", options: { fallbackPlacements: this._config.fallbackPlacements } }, { name: "offset", options: { offset: this._getOffset() } }, { name: "preventOverflow", options: { boundary: this._config.boundary } }, { name: "arrow", options: { element: `.${this.constructor.NAME}-arrow` } }, { name: "preSetPlacement", enabled: true, phase: "beforeMain", fn: (e3) => {
              this._getTipElement().setAttribute("data-popper-placement", e3.state.placement);
            } }] };
            return { ...t2, ...o(this._config.popperConfig, [t2]) };
          }
          _setListeners() {
            const t2 = this._config.trigger.split(" ");
            for (const n2 of t2) if ("click" === n2) e.on(this._element, this.constructor.eventName("click"), this._config.selector, (e2) => {
              this._initializeOnDelegatedTarget(e2).toggle();
            });
            else if ("manual" !== n2) {
              const t3 = n2 === te ? this.constructor.eventName("mouseenter") : this.constructor.eventName("focusin"), s2 = n2 === te ? this.constructor.eventName("mouseleave") : this.constructor.eventName("focusout");
              e.on(this._element, t3, this._config.selector, (e2) => {
                const t4 = this._initializeOnDelegatedTarget(e2);
                t4._activeTrigger["focusin" === e2.type ? Xe : te] = true, t4._enter();
              }), e.on(this._element, s2, this._config.selector, (e2) => {
                const t4 = this._initializeOnDelegatedTarget(e2);
                t4._activeTrigger["focusout" === e2.type ? Xe : te] = t4._element.contains(e2.relatedTarget), t4._leave();
              });
            }
            this._hideModalHandler = () => {
              this._element && this.hide();
            }, e.on(this._element.closest(En), xn, this._hideModalHandler);
          }
          _fixTitle() {
            const e2 = this._element.getAttribute("title");
            e2 && (this._element.getAttribute("aria-label") || this._element.textContent.trim() || this._element.setAttribute("aria-label", e2), this._element.setAttribute("data-bs-original-title", e2), this._element.removeAttribute("title"));
          }
          _enter() {
            this._isShown() || this._isHovered ? this._isHovered = true : (this._isHovered = true, this._setTimeout(() => {
              this._isHovered && this.show();
            }, this._config.delay.show));
          }
          _leave() {
            this._isWithActiveTrigger() || (this._isHovered = false, this._setTimeout(() => {
              this._isHovered || this.hide();
            }, this._config.delay.hide));
          }
          _setTimeout(e2, t2) {
            clearTimeout(this._timeout), this._timeout = setTimeout(e2, t2);
          }
          _isWithActiveTrigger() {
            return Object.values(this._activeTrigger).includes(true);
          }
          _getConfig(e2) {
            const t2 = b.getDataAttributes(this._element);
            for (const e3 of Object.keys(t2)) eo.has(e3) && delete t2[e3];
            return e2 = { ...t2, ..."object" == typeof e2 && e2 ? e2 : {} }, e2 = this._mergeConfigObj(e2), e2 = this._configAfterMerge(e2), this._typeCheckConfig(e2), e2;
          }
          _configAfterMerge(e2) {
            return e2.container = false === e2.container ? document.body : x(e2.container), "number" == typeof e2.delay && (e2.delay = { show: e2.delay, hide: e2.delay }), "number" == typeof e2.title && (e2.title = e2.title.toString()), "number" == typeof e2.content && (e2.content = e2.content.toString()), e2;
          }
          _getDelegateConfig() {
            const e2 = {};
            for (const [t2, n2] of Object.entries(this._config)) this.constructor.Default[t2] !== n2 && (e2[t2] = n2);
            return e2.selector = false, e2.trigger = "manual", e2;
          }
          _disposePopper() {
            this._popper && (this._popper.destroy(), this._popper = null), this.tip && (this.tip.remove(), this.tip = null);
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = P.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2]) throw new TypeError(`No method named "${e2}"`);
                t2[e2]();
              }
            });
          }
        }
        u(P);
        const ho = { ...P.Default, content: "", offset: [0, 8], placement: "right", template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>', trigger: "click" }, mo = { ...P.DefaultType, content: "(null|string|element|function)" };
        class Ae extends P {
          static get Default() {
            return ho;
          }
          static get DefaultType() {
            return mo;
          }
          static get NAME() {
            return "popover";
          }
          _isWithContent() {
            return this._getTitle() || this._getContent();
          }
          _getContentForTemplate() {
            return { ".popover-header": this._getTitle(), ".popover-body": this._getContent() };
          }
          _getContent() {
            return this._resolvePossibleFunction(this._config.content);
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = Ae.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2]) throw new TypeError(`No method named "${e2}"`);
                t2[e2]();
              }
            });
          }
        }
        u(Ae);
        const nt = ".bs.scrollspy", go = `activate${nt}`, vn = `click${nt}`, bo = `load${nt}.data-api`, K = "active", st = "[href]", mn = ".nav-link", wo = `${mn}, .nav-item > ${mn}, .list-group-item`, Oo = { offset: null, rootMargin: "0px 0px -25%", smoothScroll: false, target: null, threshold: [0.1, 0.5, 1] }, xo = { offset: "(number|null)", rootMargin: "string", smoothScroll: "boolean", target: "element", threshold: "array" };
        class me extends h {
          constructor(e2, t2) {
            super(e2, t2), this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map(), this._rootElement = "visible" === getComputedStyle(this._element).overflowY ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = { visibleEntryTop: 0, parentScrollTop: 0 }, this.refresh();
          }
          static get Default() {
            return Oo;
          }
          static get DefaultType() {
            return xo;
          }
          static get NAME() {
            return "scrollspy";
          }
          refresh() {
            this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
            for (const e2 of this._observableSections.values()) this._observer.observe(e2);
          }
          dispose() {
            this._observer.disconnect(), super.dispose();
          }
          _configAfterMerge(e2) {
            return e2.target = x(e2.target) || document.body, e2.rootMargin = e2.offset ? `${e2.offset}px 0px -30%` : e2.rootMargin, "string" == typeof e2.threshold && (e2.threshold = e2.threshold.split(",").map((e3) => Number.parseFloat(e3))), e2;
          }
          _maybeEnableSmoothScroll() {
            this._config.smoothScroll && (e.off(this._config.target, vn), e.on(this._config.target, vn, st, (e2) => {
              const t2 = this._observableSections.get(e2.target.hash);
              if (t2) {
                e2.preventDefault();
                const n2 = this._rootElement || window, s2 = t2.offsetTop - this._element.offsetTop;
                if (n2.scrollTo) return void n2.scrollTo({ top: s2, behavior: "smooth" });
                n2.scrollTop = s2;
              }
            }));
          }
          _getNewObserver() {
            const e2 = { root: this._rootElement, threshold: this._config.threshold, rootMargin: this._config.rootMargin };
            return new IntersectionObserver((e3) => this._observerCallback(e3), e2);
          }
          _observerCallback(e2) {
            const n2 = (e3) => this._targetLinks.get(`#${e3.target.id}`), s2 = (e3) => {
              this._previousScrollData.visibleEntryTop = e3.target.offsetTop, this._process(n2(e3));
            }, t2 = (this._rootElement || document.documentElement).scrollTop, o2 = t2 >= this._previousScrollData.parentScrollTop;
            this._previousScrollData.parentScrollTop = t2;
            for (const i2 of e2) {
              if (!i2.isIntersecting) {
                this._activeTarget = null, this._clearActiveClass(n2(i2));
                continue;
              }
              const a2 = i2.target.offsetTop >= this._previousScrollData.visibleEntryTop;
              if (o2 && a2) {
                if (s2(i2), !t2) return;
              } else o2 || a2 || s2(i2);
            }
          }
          _initializeTargetsAndObservables() {
            this._targetLinks = /* @__PURE__ */ new Map(), this._observableSections = /* @__PURE__ */ new Map();
            const e2 = t.find(st, this._config.target);
            for (const n2 of e2) {
              if (!n2.hash || O(n2)) continue;
              const s2 = t.findOne(decodeURI(n2.hash), this._element);
              V(s2) && (this._targetLinks.set(decodeURI(n2.hash), n2), this._observableSections.set(n2.hash, s2));
            }
          }
          _process(t2) {
            this._activeTarget !== t2 && (this._clearActiveClass(this._config.target), this._activeTarget = t2, t2.classList.add(K), this._activateParents(t2), e.trigger(this._element, go, { relatedTarget: t2 }));
          }
          _activateParents(e2) {
            if (e2.classList.contains("dropdown-item")) t.findOne(".dropdown-toggle", e2.closest(".dropdown")).classList.add(K);
            else for (const n2 of t.parents(e2, ".nav, .list-group")) for (const e3 of t.prev(n2, wo)) e3.classList.add(K);
          }
          _clearActiveClass(e2) {
            e2.classList.remove(K);
            const n2 = t.find(`${st}.${K}`, e2);
            for (const e3 of n2) e3.classList.remove(K);
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = me.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2] || e2.startsWith("_") || "constructor" === e2) throw new TypeError(`No method named "${e2}"`);
                t2[e2]();
              }
            });
          }
        }
        e.on(window, bo, () => {
          for (const e2 of t.find('[data-bs-spy="scroll"]')) me.getOrCreateInstance(e2);
        }), u(me);
        const A = ".bs.tab", ko = `hide${A}`, Ao = `hidden${A}`, So = `show${A}`, Mo = `shown${A}`, Fo = `click${A}`, To = `keydown${A}`, zo = `load${A}`, Do = "ArrowLeft", sn = "ArrowRight", Lo = "ArrowUp", Jt = "ArrowDown", it = "Home", Xt = "End", F = "active", Yt = "fade", ct = "show", Ut = ".dropdown-toggle", lt = `:not(${Ut})`, $t = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]', dt = `.nav-link${lt}, .list-group-item${lt}, [role="tab"]${lt}, ${$t}`, qo = `.${F}[data-bs-toggle="tab"], .${F}[data-bs-toggle="pill"], .${F}[data-bs-toggle="list"]`;
        class N extends h {
          constructor(t2) {
            super(t2), this._parent = this._element.closest('.list-group, .nav, [role="tablist"]'), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), e.on(this._element, To, (e2) => this._keydown(e2)));
          }
          static get NAME() {
            return "tab";
          }
          show() {
            const t2 = this._element;
            if (this._elemIsActive(t2)) return;
            const n2 = this._getActiveElem(), s2 = n2 ? e.trigger(n2, ko, { relatedTarget: t2 }) : null;
            e.trigger(t2, So, { relatedTarget: n2 }).defaultPrevented || s2 && s2.defaultPrevented || (this._deactivate(n2, t2), this._activate(t2, n2));
          }
          _activate(n2, s2) {
            n2 && (n2.classList.add(F), this._activate(t.getElementFromSelector(n2)), this._queueCallback(() => {
              "tab" === n2.getAttribute("role") ? (n2.removeAttribute("tabindex"), n2.setAttribute("aria-selected", true), this._toggleDropDown(n2, true), e.trigger(n2, Mo, { relatedTarget: s2 })) : n2.classList.add(ct);
            }, n2, n2.classList.contains(Yt)));
          }
          _deactivate(n2, s2) {
            n2 && (n2.classList.remove(F), n2.blur(), this._deactivate(t.getElementFromSelector(n2)), this._queueCallback(() => {
              "tab" === n2.getAttribute("role") ? (n2.setAttribute("aria-selected", false), n2.setAttribute("tabindex", "-1"), this._toggleDropDown(n2, false), e.trigger(n2, Ao, { relatedTarget: s2 })) : n2.classList.remove(ct);
            }, n2, n2.classList.contains(Yt)));
          }
          _keydown(e2) {
            if (![Do, sn, Lo, Jt, it, Xt].includes(e2.key)) return;
            e2.stopPropagation(), e2.preventDefault();
            const n2 = this._getChildren().filter((e3) => !O(e3));
            let t2;
            if ([it, Xt].includes(e2.key)) t2 = n2[e2.key === it ? 0 : n2.length - 1];
            else {
              const s2 = [sn, Jt].includes(e2.key);
              t2 = ht(n2, e2.target, s2, true);
            }
            t2 && (t2.focus({ preventScroll: true }), N.getOrCreateInstance(t2).show());
          }
          _getChildren() {
            return t.find(dt, this._parent);
          }
          _getActiveElem() {
            return this._getChildren().find((e2) => this._elemIsActive(e2)) || null;
          }
          _setInitialAttributes(e2, t2) {
            this._setAttributeIfNotExists(e2, "role", "tablist");
            for (const e3 of t2) this._setInitialAttributesOnChild(e3);
          }
          _setInitialAttributesOnChild(e2) {
            e2 = this._getInnerElement(e2);
            const t2 = this._elemIsActive(e2), n2 = this._getOuterElement(e2);
            e2.setAttribute("aria-selected", t2), n2 !== e2 && this._setAttributeIfNotExists(n2, "role", "presentation"), t2 || e2.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(e2, "role", "tab"), this._setInitialAttributesOnTargetPanel(e2);
          }
          _setInitialAttributesOnTargetPanel(e2) {
            const n2 = t.getElementFromSelector(e2);
            n2 && (this._setAttributeIfNotExists(n2, "role", "tabpanel"), e2.id && this._setAttributeIfNotExists(n2, "aria-labelledby", `${e2.id}`));
          }
          _toggleDropDown(e2, n2) {
            const s2 = this._getOuterElement(e2);
            if (!s2.classList.contains("dropdown")) return;
            const o2 = (e3, o3) => {
              const i2 = t.findOne(e3, s2);
              i2 && i2.classList.toggle(o3, n2);
            };
            o2(Ut, F), o2(".dropdown-menu", ct), s2.setAttribute("aria-expanded", n2);
          }
          _setAttributeIfNotExists(e2, t2, n2) {
            e2.hasAttribute(t2) || e2.setAttribute(t2, n2);
          }
          _elemIsActive(e2) {
            return e2.classList.contains(F);
          }
          _getInnerElement(e2) {
            return e2.matches(dt) ? e2 : t.findOne(dt, e2);
          }
          _getOuterElement(e2) {
            return e2.closest(".nav-item, .list-group-item") || e2;
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = N.getOrCreateInstance(this);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2] || e2.startsWith("_") || "constructor" === e2) throw new TypeError(`No method named "${e2}"`);
                t2[e2]();
              }
            });
          }
        }
        e.on(document, Fo, $t, function(e2) {
          ["A", "AREA"].includes(this.tagName) && e2.preventDefault(), O(this) || N.getOrCreateInstance(this).show();
        }), e.on(window, zo, () => {
          for (const e2 of t.find(qo)) N.getOrCreateInstance(e2);
        }), u(N);
        const y = ".bs.toast", Xo = `mouseover${y}`, Qo = `mouseout${y}`, Zo = `focusin${y}`, Jo = `focusout${y}`, ei = `hide${y}`, ti = `hidden${y}`, ni = `show${y}`, si = `shown${y}`, Pt = "hide", Ce = "show", pe = "showing", ri = { animation: "boolean", autohide: "boolean", delay: "number" }, ci = { animation: true, autohide: true, delay: 5e3 };
        class we extends h {
          constructor(e2, t2) {
            super(e2, t2), this._timeout = null, this._hasMouseInteraction = false, this._hasKeyboardInteraction = false, this._setListeners();
          }
          static get Default() {
            return ci;
          }
          static get DefaultType() {
            return ri;
          }
          static get NAME() {
            return "toast";
          }
          show() {
            e.trigger(this._element, ni).defaultPrevented || (this._clearTimeout(), this._config.animation && this._element.classList.add("fade"), this._element.classList.remove(Pt), oe(this._element), this._element.classList.add(Ce, pe), this._queueCallback(() => {
              this._element.classList.remove(pe), e.trigger(this._element, si), this._maybeScheduleHide();
            }, this._element, this._config.animation));
          }
          hide() {
            this.isShown() && (e.trigger(this._element, ei).defaultPrevented || (this._element.classList.add(pe), this._queueCallback(() => {
              this._element.classList.add(Pt), this._element.classList.remove(pe, Ce), e.trigger(this._element, ti);
            }, this._element, this._config.animation)));
          }
          dispose() {
            this._clearTimeout(), this.isShown() && this._element.classList.remove(Ce), super.dispose();
          }
          isShown() {
            return this._element.classList.contains(Ce);
          }
          _maybeScheduleHide() {
            this._config.autohide && (this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
              this.hide();
            }, this._config.delay)));
          }
          _onInteraction(e2, t2) {
            switch (e2.type) {
              case "mouseover":
              case "mouseout":
                this._hasMouseInteraction = t2;
                break;
              case "focusin":
              case "focusout":
                this._hasKeyboardInteraction = t2;
            }
            if (t2) return void this._clearTimeout();
            const n2 = e2.relatedTarget;
            this._element === n2 || this._element.contains(n2) || this._maybeScheduleHide();
          }
          _setListeners() {
            e.on(this._element, Xo, (e2) => this._onInteraction(e2, true)), e.on(this._element, Qo, (e2) => this._onInteraction(e2, false)), e.on(this._element, Zo, (e2) => this._onInteraction(e2, true)), e.on(this._element, Jo, (e2) => this._onInteraction(e2, false));
          }
          _clearTimeout() {
            clearTimeout(this._timeout), this._timeout = null;
          }
          static jQueryInterface(e2) {
            return this.each(function() {
              const t2 = we.getOrCreateInstance(this, e2);
              if ("string" == typeof e2) {
                if (void 0 === t2[e2]) throw new TypeError(`No method named "${e2}"`);
                t2[e2](this);
              }
            });
          }
        }
        return ve(we), u(we), { Alert: ue, Button: be, Carousel: Z, Collapse: ae, Dropdown: m, Modal: G, Offcanvas: E, Popover: Ae, ScrollSpy: me, Tab: N, Toast: we, Tooltip: P };
      });
    }
  });
  require_stdin();
})();
/*!
  * Bootstrap v5.3.3 (https://getbootstrap.com/)
  * Copyright 2011-2024 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
